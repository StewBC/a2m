// Apple ][+ and //e Enhanced emulator with assembler
// Stefan Wessels, 2025
// This is free and unencumbered software released into the public domain.

// NM = #D0D0D0
// BG = #D2D2D2
// H0 = #00B7FF
// H1 = #00E5A8
// H2 = #FFD84D
// H3 = #B388FF
// BO = #FF9F43
// QU = #7CFF00
// TB = #FF6B6B

const int unk_help_page_count = 4;

const char *unk_page_titles[] = {
    "Views",
    "Dialogs",
    "Assembler",
    "Config"
};

const char *unk_help_text[] = {
"<#H0>Quick Key Reference<#NM>\n"
"In both Normal and Debug Mode, these keys have the listed meanings:\n"
"<#TB>Key         Action                      Key   Action<#NM>\n"
"F1          Show Help                   F2    Toggle Debug Mode View\n"
"F5          Run                         F6    Run to cursor\n"
"F7                                      F8\n"
"F9          Toggle Breakpoint           F10   Step\n"
"F11         Break                       F12   Monitor Select\n"
"SHIFT+F11   Step Out\n"
"\n"
"Debug Mode (<#QU>F2<#NM>) also reveals the Miscellaneous view, and it is here where disks can be inserted, making the Apple 2 really useful.\n"
"\n"
"<#H0>Running a2m<#NM>\n"
"a2m can be launched from the command line or as a GUI application without a console window.\n"
"\n"
"<#H1>Command Line<#NM>\n"
"Running a2m is as simple as executing the program with any desired switches.\n"
"Use <#QU>--help<#NM> (or <#QU>-h<#NM>) to view the full command-line reference.\n"
"\n"
"<#H1>INI Files<#NM>\n"
"a2m supports configuration through INI files. They are optional but handy for storing common setups (for example, per-game configurations).\n"
"\n"
"Use <#QU>--inifile <file><#NM> (or <#QU>-i <file><#NM>) to load a specific INI file at launch.\n"
"By default, a2m loads <#QU>a2m.ini<#NM> from the current directory.\n"
"\n"
"See <#BO>INI Files in Depth<#NM> for full details.\n"
"\n"
"<#H0>User Interface<#NM>\n"
"a2m is primarily a GUI-based Apple 2 emulator. It also supports a text-based mode, enabled with <#QU>--ui text<#NM> (or <#QU>-u text<#NM>). This mode exists mostly as a demonstration of the cleaner architecture introduced after v1.0.\n"
"\n"
"In text mode, the emulator boots into BASIC and accepts input directly from the terminal. If the Apple 2 switches to graphics, you simply will not see it. Typed keys are sent to <#QU>$C000<#NM>, and characters printed by the emulated machine appear in the terminal. This manual does not describe text mode further.\n"
"\n"
"<#H0>Normal Mode<#NM>\n"
"When launched normally, a2m displays the Apple 2's video output in the full application window. It behaves like a ][+ or //e.\n"
"The Apple 2 will attempt to boot from:\n"
"<#H0>* <#BO>Slot 6 Drive 0<#NM> (floppy), or\n"
"<#H0>* <#BO>Slot 7 Device 0<#NM> (hard-disk image)\n"
"\n"
"These defaults can be overridden in an INI file.\n"
"\n"
"<#H1>Keyboard Usage<#NM>\n"
"Regular keys are sent directly to the emulated Apple 2. Function keys control the debugger, which is always running \"behind the scenes\" even when the Apple 2 display fills the window.\n"
"\n"
"On the //e model:\n"
"<#H0>* <#BO>Open-Apple<#NM> - joystick button A or Left-ALT\n"
"<#H0>* <#BO>Closed-Apple<#NM> - joystick button B or Right-ALT\n"
"\n"
"To paste text into the Apple 2, use <#BO>SHIFT+INSERT<#NM>.\n"
"<#BO>PAUSE<#NM> acts as RESET. Some laptops require combinations such as <#BO>Fn+B<#NM> or <#BO>Fn+P<#NM>.\n"
"<#BO>F1<#NM> opens a help screen and pauses emulation.\n"
"All other function keys remain debugger controls even while in Normal Mode.\n"
"\n"
"<#H1>Resizing<#NM>\n"
"The window can be resized using standard OS controls.\n"
"The Apple 2 display is always drawn within the largest 4:3 region that fits inside the window's client area.\n"
"\n"
"<#H0>Debug Mode<#NM>\n"
"Debug Mode is where a2m really shines. Every part of the emulated Apple 2 can be inspected, and many parts can be modified.\n"
"\n"
"Although Debug Mode is often described as a separate mode, it is always active. All function keys route to the debugger even when only the Apple 2 display is visible. Once the debugger views are shown, the full set of tools becomes available.\n"
"\n"
"<#H1>Keyboard controls<#NM>\n"
"The following keys control the debugger regardless of whether the Debug Mode View is open (via F2):\n"
"\n"
"<#TB>Key         Action                      Key   Action<#NM>\n"
"F1          Show Help                   F2    Toggle Debug Mode View\n"
"F5          Run                         F6    Run to cursor\n"
"F7                                      F8\n"
"F9          Toggle Breakpoint           F10   Step\n"
"F11         Break                       F12   Monitor Select\n"
"SHIFT+F11   Step Out\n"
"\n"
"<#H1>Opening the Debugger<#NM>\n"
"Press <#BO>F2<#NM> to open the Debug Mode View. Press <#BO>F2<#NM> again to hide it. The following table represents the layout of the Debugger Views, when opened.\n"
"\n"
"<#TB>Position               View<#NM>\n"
"Upper left:            Apple 2 display\n"
"Upper right:           CPU view\n"
"Right, below CPU:      Disassembly view\n"
"Lower left:            Memory view (hex + text; any bank can be inspected)\n"
"Lower right:           Miscellaneous view (slot configuration, disks, soft-switches, breakpoints, etc.)\n"
"\n"
"<#H1>Basic UI Philosophy<#NM>\n"
"a2m uses the <#BO>Nuklear<#NM> immediate-mode GUI library. Nuklear uses a <#BO>hover-active<#NM> model: when the CPU is stopped, whichever view the mouse is over becomes active and receives input. Active views have a green header; inactive ones use grey.\n"
"When the emulator is running, all keys except function keys and SHIFT+INSERT go to the Apple 2.\n"
"In the rest of this manual, \"in Debug Mode\" is omitted for brevity-assume Debug Mode unless noted.\n"
"\n"
"<#H2>The debugger layout is resizable<#NM>\n"
"<#H0>*<#NM> a <#BO>vertical slider<#NM> between the Apple 2 and the CPU/Disassembly views\n"
"<#H0>*<#NM> a <#BO>horizontal slider<#NM> between the Apple 2 and the Memory/Misc views\n"
"Dragging these sliders resizes the layout.\n"
"A <#BO>hot spot<#NM> in the lower-right corner of the Apple 2 view moves both sliders together, scaling the layout proportionally.\n"
"If the Apple 2 view is letterboxed, clicking this <#BO>hot spot<#NM> snaps it back to a perfect 4:3 region.\n"
"\n"
"<#H1>Apple 2 View<#NM>\n"
"As in Normal Mode, the Apple 2 display is always shown in a 4:3 region inside the largest area available.\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"When the emulator is running, regular keys go to the Apple 2, while function keys and SHIFT+INSERT always go to the debugger.\n"
"\n"
"See <#BO>Disassembly View - Keyboard controls<#NM> for details on function-key behaviour.\n"
"\n"
"<#H1>CPU View<#NM>\n"
"The CPU view shows the program counter (PC), stack pointer (SP), registers, and flags.\n"
"When the emulator is stopped, these can be edited by typing new values:\n"
"\n"
"<#H0>* <#BO>PC and SP<#NM>: 16-bit hex\n"
"<#H0>* <#BO>Registers<#NM>: 8-bit hex\n"
"<#H0>* <#BO>Flags<#NM>: 0 (off) or 1 (on)\n"
"\n"
"Flags are:\n"
"<#H0>* <#BO>N<#NM> - Negative\n"
"<#H0>* <#BO>V<#NM> - oVerflow\n"
"<#H0>* <#BO>E<#NM> - ignorEd\n"
"<#H0>* <#BO>B<#NM> - Break\n"
"<#H0>* <#BO>D<#NM> - Decimal mode\n"
"<#H0>* <#BO>I<#NM> - Interrupt\n"
"<#H0>* <#BO>Z<#NM> - Zero\n"
"<#H0>* <#BO>C<#NM> - Carry\n"
"\n"
"<#H1>Disassembly View<#NM>\n"
"The disassembly view shows the code being executed by the CPU. When running or stepping, the current instruction (at the PC) is highlighted. Other highlighted lines include:\n"
"\n"
"<#H0>*<#NM> the cursor\n"
"<#H0>*<#NM> any addresses with a <#BO>stop<#NM> breakpoint\n"
"  (breakpoints with non-stop actions do not appear highlighted)\n"
"\n"
"Each line follows this general format:\n"
"<#QU>C27D: WAITKEY1      E6 4E       INC RNDL<#NM>\n"
"Broken down:\n"
"\n"
"<#TB>Element   Meaning<#NM>\n"
"C27D       The hexadecimal address in RAM\n"
"WAITKEY1   A label for that address (if present)\n"
"E6 4E      The raw bytes at the address at the start of the line\n"
"INC RNDL   The disassembled instruction (with symbols resolved when available)\n"
"\n"
"See <#BO>Symbols Dialog<#NM> for more information.\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"These keys apply <#BO>when emulation is stopped:<#NM>\n"
"\n"
"<#TB>Key             Action<#NM>\n"
"C+a             Edit the memory address of the cursor line\n"
"C+S+b           Open the Assembler Configuration Dialog\n"
"C+b             Assemble the configured source file\n"
"C+e             Show the assembler errors dialog\n"
"C+p             Set the PC to the cursor address\n"
"C+s             Open the symbol lookup dialog\n"
"ENTER           Finish \"edit memory address\" mode\n"
"TAB             Cycle through symbol / branch offset / raw hex display modes\n"
"HOME            Move the cursor to the top of the view\n"
"C+HOME          Jump to address <#QU>$0000<#NM>\n"
"END             Move the cursor to the last line of the view\n"
"C+END           Jump to address <#QU>$FFFF<#NM>\n"
"UP/DOWN         Move the cursor, scrolling if needed\n"
"LEFT            Scroll to show the cursor\n"
"C+LEFT          Set PC to cursor and scroll to it\n"
"RIGHT           Scroll to show the PC\n"
"C+RIGHT         Set cursor to PC and scroll to it\n"
"PAGE UP         Page up by one full view\n"
"PAGE DOWN       Page down by one full view\n"
"\n"
"<#BO>C+ and S+ mean CONTROL+ and SHIFT+, respectively.<#NM>\n"
"\n"
"<#H2>Mouse Controls<#NM>\n"
"At the bottom of the view are <#BO>selector buttons<#NM> that choose which memory bank to display.\n"
"On the Apple ][+ model, the 128 K option is disabled.\n"
"\n"
"<#TB>Label    Action<#NM>\n"
"6502      Shows the CPU's current live memory map\n"
"64K       Shows the first 64 K regardless of soft-switch configuration\n"
"128K      On the //e, shows the auxiliary bank\n"
"LC Bank   Toggles between the two language-card banks\n"
"\n"
"The <#BO>scrollbar<#NM> on the right scrolls from address <#QU>$0000<#NM> to <#QU>$FFFF<#NM>.\n"
"A mouse <#BO>scroll wheel<#NM> scrolls by 4 lines. Scroll sensitivity can be configured (see <#BO>INI Files in Depth - Config<#NM>).\n"
"\n"
"Click on any row, outside the address section, to put the cursor on that row. Click on the address section to set the address of that row (Same as pressing CTRL+a).\n"
"\n"
"<#H1>Memory View<#NM>\n"
"The memory view is a way of inspecting larger areas of the Apple 2 RAM. The display shows rows of memory in the format:\n"
"\n"
"<#QU>0000: 54 68 69 73 20 69 73 20 41 53 43 49 49 00 00 00 This is ASCII...<#NM>\n"
"Broken down:\n"
"\n"
"<#TB>Element      Meaning<#NM>\n"
"0000         The hexadecimal address in RAM\n"
"54 68 ..     The bytes starting at the address at the start of the line\n"
"This is ..   The ASCII representation of the bytes (<#QU>54<#NM> is <#QU>T<#NM>, <#QU>68<#NM> is <#QU>h<#NM>, etc.)\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"These keys apply <#BO>when emulation is stopped:<#NM>\n"
"\n"
"<#TB>Key             Action<#NM>\n"
"0..9, a..f      In the HEX portion, type hexadecimal characters to edit the memory\n"
"ASCII           In the ASCII portion, type ASCII letters to set the memory\n"
"C+a             Edit the memory address of the cursor line\n"
"C+f             Open the find dialog box\n"
"C+n             Search forward for the find string (find next)\n"
"C+S+n           Search backward for the find string (find previous)\n"
"C+s             Open the symbol lookup dialog\n"
"C+t             Switch between Hex and ASCII editing\n"
"C+v             Split the view, up to 16 times, into independent sub-views\n"
"C+j             Join the sub-view with its neighbouring sub-view\n"
"A+UP            Switch to the sub-view above the current sub-view\n"
"A+DOWN          Switch to the sub-view below the current sub-view\n"
"ENTER           Finish \"edit memory address\" mode\n"
"HOME            Move the cursor to the start of the current line\n"
"C+HOME          Move the cursor to the top of the view\n"
"END             Move the cursor to the end of the current line\n"
"C+END           Move the cursor to the end of the last line of the view\n"
"UP/DOWN         Move the cursor up or down, scrolling if needed\n"
"C+UP/DOWN       Scroll the view one line up or down\n"
"LEFT/RIGHT      Move the cursor left or right, wrapping to previous/next row if needed\n"
"PAGE UP         Page up by one full view\n"
"PAGE DOWN       Page down by one full view\n"
"S+INSERT        Paste from the OS clipboard (HEX into address and HEX, ASCII into ASCII)\n"
"\n"
"<#BO>A+, C+ and S+ mean ALT+, CONTROL+ and SHIFT+, respectively.<#NM>\n"
"\n"
"<#H2>Mouse Controls<#NM>\n"
"The <#BO>scrollbar<#NM> on the right scrolls from address <#QU>$0000<#NM> to <#QU>$FFFF<#NM>.\n"
"A mouse <#BO>scroll wheel<#NM> scrolls by 4 lines. Scroll sensitivity can be configured (see <#BO>INI Files in Depth - Config<#NM>).\n"
"\n"
"Click on any row, outside the address section, to place the cursor on that row. Click on the address section to set the address of that row (same as pressing CTRL+a).\n"
"\n"
"<#H1>Miscellaneous View<#NM>\n"
"The Miscellaneous View consists of sub-views that can be opened and closed at will. Each sub-view has a triangle to the left of its name; clicking the triangle opens or closes the sub-view. The Miscellaneous View also has a scrollbar on the right, making it possible to see all details without closing any sub-views.\n"
"The sub-views are:\n"
"\n"
"<#TB>View Name       Contents<#NM>\n"
"Slots           Devices inside the Apple 2 slots, such as Disk II or SmartPort cards\n"
"Debugger        Cycle counters, call stack, breakpoints, etc.\n"
"Soft Switches   Memory locations in the $C000-$C0FF range that affect Apple 2 operations\n"
"\n"
"Each of these is discussed in more detail below.\n"
"\n"
"<#H2>Slots Misc View<#NM>\n"
"The Slots view shows the hardware installed in the slots of the Apple 2. It is also the panel used for working with disks, both SmartPort and floppy.\n"
"\n"
"With both SmartPort and floppy devices, there are a few buttons exposed. Next to Disk or Device 0, there is a button with the slot number, a dot, and a zero. Next to that is an Eject button, followed by an Insert button. The display looks something like this:\n"
"<#QU>"
"Slot 5: Smartport\n"
"[5.0][Eject][Insert]\n"
"Slot 6: Disk II\n"
"[6.0][Eject][Insert]\n"
"<#NM>\n"
"Clicking Insert opens the file browser, and if an appropriate file is selected (NIB for Disk II and any file for SmartPort), the file name is shown to the right of the Insert button. For a Disk II device, more than one file can be inserted. When this is done, a new button appears, labelled Swap. The button also indicates which disk is currently inserted (from the sequence) and how many disks are in the sequence. This looks like:\n"
"<#QU>[6.0][Eject][Insert][Swap (1/2)] This is disk 1.po<#NM>\n"
"\n"
"The disk name, in this case, is \"This is disk 1.po\", and the button indicates that it is the first disk of two disks in the queue. Clicking the Swap button switches to the second disk, and the display might then look like this if the second disk is called \"This is disk 2.po\":\n"
"<#QU>[6.0][Eject][Insert][Swap (2/2)] This is disk 2.po<#NM>\n"
"\n"
"Clicking Eject removes the currently selected disk from the drive and from the queue.\n"
"\n"
"Clicking the button labelled <#QU>[Slot.0]<#NM> boots the disk in drive/device 0 of that slot.\n"
"\n"
"<#H2>Debugger Misc View<#NM>\n"
"By default, the Debugger View shows status information under the heading <#BO>Debug Status<#NM>. This information is:\n"
"\n"
"<#TB>Name             Description<#NM>\n"
"Run to PC nnnn   The button is selected when stepping over a JSR or using F6, and the\n"
"                 destination address is in nnnn. Otherwise, the button is unselected and\n"
"                 nnnn contains 0000\n"
"Step Out         The button is selected when F11 is used to step out of the current\n"
"                 subroutine\n"
"Step Cycles      The number of cycles between stops of the emulator. For example,\n"
"                 stepping over an INC of ZP will show 5 cycles, but stepping over a JSR\n"
"                 will show however many cycles the subroutine cost, plus the 6 JSR cycles\n"
"Total Cycles     Shows the total cycles since the emulator started running the\n"
"                 Apple 2 ROM code\n"
"\n"
"There is also a <#BO>Call Stack<#NM> display. This is a window with its own scrollbar if the entries exceed what the window can show. The call stack entries have the form:\n"
"<#QU>E69E JSR FF59 OLDRST<#NM>\n"
"Broken down:\n"
"\n"
"<#TB>Element   Meaning<#NM>\n"
"E69E      The hexadecimal address where the JSR resides\n"
"JSR       The instruction that caused the push onto the stack\n"
"FF59      The destination address of the JSRâ€”the address of the subroutine called\n"
"OLDRST    The symbol name for $FF59, from the loaded symbol files\n"
"\n"
"Note that clicking the address (<#QU>E69E<#NM> in this case) will set the disassembly view cursor to that address and show it in the disassembly view. The same is true for <#QU>FF59<#NM>; clicking it, or clicking to the right of the JSR, will place the disassembly cursor on that address and show it in the disassembly view.\n"
"\n"
"<#H3>Breakpoints<#NM>\n"
"The Debugger View has a breakpoints view that is only visible when at least one breakpoint is set. This view lists all configured breakpoints. Each breakpoint in this view has the format:\n"
"<#QU>label [Edit][Disable][View PC][Clear]<#NM>\n"
"\n"
"The label describes the breakpoint. These are all possible label values, where nnnn is the address of the breakpoint:\n"
"\n"
"<#TB>Label                  Meaning<#NM>\n"
"nnnn (counters)        Uses a counter\n"
"nnnn Fast              Sets the Turbo Mode to Fast\n"
"nnnn Restore           Restores the Turbo Mode to the value before it was set to Fast\n"
"nnnn Slow              Sets the Turbo Mode to Slow\n"
"nnnn Swap sxdy         Swaps the Disk II disk in Slot x Drive y to the next disk in the queue\n"
"nnnn Troff             Turns file trace logging off\n"
"nnnn Tron              Turns file trace logging on, to the file ./trace.txt\n"
"nnnn Type              Types keys on the Apple II keyboard (<#QU>\\r<#NM>, <#QU>123<#NM>, or <#QU>\\x0a<#NM>, for example)\n"
"z[Range]               Stop on specified access to an address in the range\n"
"z[Range] (counters)    Stop on specified access to an address in the range, subject to counters\n"
"z[nnnn]                Stop on specified access to an address\n"
"z[nnnn] (counters)     Stop on specified access to an address, subject to counters\n"
"\n"
"For type keys, the mechanism is similar to how paste works. When address <#QU>$C010<#NM> is accessed, another key is inserted into the <#QU>$C000<#NM> keyboard address for the Apple 2 to read. This is useful for pressing a key when, for example, there is a prompt that says \"Insert disk 2 and press enter\". Type can be used in conjunction with Swap to swap disk 2 in, press enter, and continue execution without user intervention.\n"
"\n"
"In the above table, these symbols mean:\n"
"\n"
"<#TB>Symbol       Meaning<#NM>\n"
"nnnn         Hexadecimal memory location\n"
"(counters)   Takes the form (x/y), where x means the address has been accessed x times and\n"
"             the stop will occur when x equals y\n"
"[Range]      Takes the form [xxxx-yyyy], where x and y are the start and end addresses of an\n"
"             address range in which any access will count\n"
"z            Represents R for read access, W for write access, and RW for read or write access\n"
"\n"
"<#H0>*<#NM> The <#QU>[Edit]<#NM> button opens the edit breakpoints dialog.\n"
"<#H0>*<#NM> The <#QU>[Disable]<#NM> button leaves the breakpoint in the list but ignores it. This is useful for leaving bookmarks in memory, as the <#QU>[View PC]<#NM> button will still jump to the location of that disabled breakpoint.\n"
"<#H0>*<#NM> The <#QU>[View PC]<#NM> button sets the disassembly view cursor to the nnnn address of the breakpoint and brings it into view.\n"
"<#H0>*<#NM> The <#QU>[Clear]<#NM> button deletes the breakpoint.\n"
"<#H0>*<#NM> When there is more than one breakpoint, a <#QU>[Clear All]<#NM> button appears at the top of the list to delete all breakpoints (including disabled ones).\n"
"\n"
"<#H2>Soft Switches Misc View<#NM>\n"
"The soft switches view shows the addresses of soft switches in the Apple //e (currently even in Apple ][+ mode). These are read-only, but there is a button to override the display switches. When the override is enabled, the interface does not change the hardware settings, but it behaves as though the hardware is set to the user settings from a UI perspective.\n"
"\n"
"For example, setting Mixed to ON will draw the Apple 2 screen as though Mixed is enabled. This is quite useful when drawing to an off-screen buffer. The override can be turned on and the off-screen buffer can be set as the visible buffer so that the drawing can be seen on-screen. When the display override is turned off, all switches return to showing their actual settings.\n"
"\n"
"Note that the addresses work in pairs, and only the first address is shown in the table. The odd address turns the setting on, and the even address turns the setting off. For example, <#QU>$C000<#NM> sets <#QU>80STORE<#NM> and <#QU>$C001<#NM> clears <#QU>80STORE<#NM>.\n"
"\n"
"<#TB>Address   Meaning<#NM>\n"
"C000      80STORE\n"
"C003      RAMRD\n"
"C005      RAMWRT\n"
"C007      CXROM\n"
"C009      ALTZP\n"
"C00B      C3ROM\n"
"C00D      80COL\n"
"C00F      ALTCHAR\n"
"C051      TEXT\n"
"C053      MIXED\n"
"C055      PAGE2\n"
"C057      HIRES\n"
"C05E      DHGR\n"
"C08x      LCBANK\n"
"C08x      LCREAD\n"
"C08X      LCPREWRITE\n"
"C08X      LCWRITE\n"
,
"<#H0>Dialogs<#NM>\n"
"The dialog boxes are activated from various views and reused wherever needed in a2m.\n"
"\n"
"<#H1>File Browser Dialog<#NM>\n"
"This is a simple single-file selection dialog. A single mouse click is used to activate an action. The actions are <#QU>select a file<#NM> or <#QU>select a folder<#NM>. Selecting a folder enters that folder and updates the display to show the files and folders within it. The folder <#QU>..<#NM> is the parent of the current folder. Folders are sorted to the top of the dialog, followed by files.\n"
"\n"
"Press the <#QU>[OK]<#NM> button to close the dialog. If a file is highlighted when <#QU>[OK]<#NM> is pressed, that file becomes the selected file.\n"
"\n"
"<#H1>Breakpoint Editor<#NM>\n"
"The breakpoint editor dialog is used to change the way a breakpoint works. In it you can configure the address or address range that a breakpoint activates on, and whether that activation is on execution, read, write, or read or write. Actions can also be assigned to breakpoints here, as well as counters, as discussed in the Breakpoints section.\n"
"\n"
"The dialog has <#QU>Break At [nnnn] on [] PC [] Address Access<#NM>. In this, <#QU>nnnn<#NM> is the memory address to watch for an execution break if <#QU>on PC<#NM> is checked. If <#QU>Address Access<#NM> is checked, the breakpoint will activate on a read, write, or either. This depends on the checked state of <#QU>[] Read [] Write<#NM>, which is available if <#QU>Address Access<#NM> is chosen. Also available when <#QU>Address Access<#NM> is chosen is <#QU>[] Range<#NM>. Check <#QU>Range<#NM> to enter a second address. All selected accesses between the <#QU>Break At<#NM> and <#QU>Range<#NM> addresses will now cause a stop.\n"
"\n"
"The <#QU>Actions:<#NM>\n"
"\n"
"<#TB>Action    Meaning<#NM>\n"
"Break     Default action. Puts the emulator in a stopped state.\n"
"Fast      Switches the Turbo Mode to <#QU>max<#NM>.\n"
"Restore   Switches the Turbo Mode to the last mode active through the <#QU>F3<#NM> setting\n"
"Slow      Switches the Turbo Mode to 1 MHz.\n"
"Swap      Enter the slot and drive, and a swap is done on that floppy.\n"
"Troff     Turns off trace file logging.\n"
"Tron      Turns on trace logging to a file called <#QU>./trace.txt<#NM>.\n"
"Type      Enter text to be \"typed\" into the Apple 2 when the breakpoint is hit\n"
"\n"
"Lastly, there is the <#QU>[] use Counter<#NM> setting. Select this option to enter two counter values. The first value is how many times the breakpoint must be hit before it causes its action, and the second value specifies what value to install as the counter once the breakpoint has been hit. As an example, setting <#QU>Counter<#NM> to 10 and <#QU>Reset Counter<#NM> to 2 means that the breakpoint must be hit 10 times before its action is executed, and after that it will only execute the action every second time the breakpoint is hit.\n"
"\n"
"Using <#QU>[Cancel]<#NM> will not apply any changes to the breakpoint, but pressing <#QU>[Apply]<#NM> will apply the changes to the breakpoint.\n"
"\n"
"<#H1>Symbols Dialog<#NM>\n"
"The symbol search dialog has a search box at the top and two buttons, <#QU>[OK]<#NM> and <#QU>[Cancel]<#NM>, at the bottom. In the middle is a list of names, addresses, and a symbol source name.\n"
"\n"
"Typing into the symbol search box performs a search on the name and the symbol source, and any matching symbols are shown in the middle section. For example, typing <#QU>PP<#NM> might show all symbols from the A<#QU>PP<#NM>LE2E source, as well as <#QU>A.TEMPP<#NM>T from the A2_BASIC source.\n"
"\n"
"Clicking on any line in the middle section, for example <#QU>A.TEMPPT $0052 A2_BASIC<#NM>, sets the Disassembly View cursor to address <#QU>$0052<#NM> and makes the cursor visible in the Disassembly View.\n"
"\n"
"Clicking <#QU>[OK]<#NM> closes the dialog.\n"
"\n"
"<#H1>Find Dialog<#NM>\n"
"The find dialog has selectors for string or hexadecimal searches. When searching for strings, type the ASCII characters to search for into the search box. When searching for hexadecimal values, type the hex values as two-digit hex numbers, not separated by any characters (for example <#QU>01abcd<#NM>), and press ENTER or click <#QU>[OK]<#NM>.\n"
"\n"
"Below the <#QU>[OK][Cancel]<#NM> buttons is a status string. This normally reads <#QU>Okay<#NM>. If, for example, you enter a search of <#QU>012<#NM> into the search field and press ENTER, the status message will indicate an error. In this case, the error would be <#QU>Uneven # of hex digits<#NM>, meaning that the number of hex digits must be even (pairs of two) for the search to work.\n"
,
"<#H0>Using the Assembler<#NM>\n"
"In the section titled <#QU>Disassembly View<#NM>, it was shown how to set an assembler file to assemble (<#QU>CTRL+SHIFT+b<#NM>) and how to invoke the assembler (<#QU>CTRL+b<#NM>). In the following sections, the assembler is covered in more detail, including syntax and commands.\n"
"\n"
"In the remainder of the assembler documentation, 6502 means 6502 or 65C02, unless specifically stated otherwise.\n"
"\n"
"<#H1>Invoking from the command line<#NM>\n"
"The assembler can also be used stand-alone using the program <#QU>asm6502<#NM>. This is the same assembler used in the emulator, but with a command-line interface.\n"
"\n"
"The <#QU>asm6502<#NM> executable, when used with no command-line arguments, displays this help message:\n"
"<#QU>\n"
"Usage: asm6502 <-i infile> [-o outfile] [-s symbolfile] [-v]\n"
"Where: infile is a 6502 assembly language file\n"
"       outfile will be a binary file containing the assembled 6502\n"
"       symbolfile contains a list of the addresses of all the named variables and labels\n"
"       -v turns on verbose and will dump the hex 6502 as it is assembled\n"
"<#NM>\n"
"It is worth noting that assembly files can include other assembly files. This can be seen in <#QU>samples/mminer/mminer.asm<#NM>.\n"
"\n"
"<#H1>Assembler Features and Syntax<#NM>\n"
"The assembler supports these features:\n"
"\n"
"<#TB>Feature          Description<#NM>\n"
"6502 mnemonics   All standard opcodes and addressing modes\n"
"labels           Labels start with <#QU>a-z<#NM> or <#QU>_<#NM> and can contain numbers. A label ends with <#QU>:<#NM>\n"
"variables        Values can be assigned and used in expressions\n"
".commands        Dot commands are described below\n"
"comments         The comment character is <#QU>;<#NM>; everything after <#QU>;<#NM> on a line is ignored\n"
"address          The address character is <#QU>*<#NM>; it can be assigned and read\n"
"expressions      The assembler has a full expression parser\n"
"\n"
"There is a set of directives that control how a 6502 source file is assembled. These are referred to as <#QU>dot commands<#NM>, since each keyword starts with a <#QU>.<#NM>. The available <#QU>dot commands<#NM> are:\n"
"\n"
"<#TB>Command          Meaning<#NM>\n"
".6502            Only 6502 opcodes are valid. 65C02 opcodes are not valid and will cause errors\n"
".65c02           Both 6502 and 65C02 opcodes are valid\n"
".org n           Set the assembly location to address n. Another way to specify <#QU>* =<#NM>\n"
".align v         Align to v bytes, inserting up to v-1 zeroes into the output\n"
".byte b          Insert b as a byte into the output\n"
".word w          Insert the word bytes w into the output\n"
".dword dw        Insert the double-word bytes dw into the output (low byte first)\n"
".qword qw        Insert the quad-word bytes qw into the output\n"
".drow w          Insert the word bytes w into the output in reverse order\n"
".drowd dw        Insert the double-word bytes dw into the output in reverse order\n"
".drowq qw        Insert the quad-word bytes qw into the output in reverse order\n"
".if p            Conditional assembly where p is a condition such as <#QU>.if c .eq 1<#NM>\n"
".else            The else part of a conditional <#QU>.if<#NM> directive\n"
".endif           Ends a <#QU>.if<#NM> conditional assembler directive\n"
".for p           Start a loop where p has the form <#QU><initializer>, <condition>, <iteration><#NM>\n"
".endfor          Ends a <#QU>.for<#NM> loop assembler directive\n"
".macro n p       Start a macro procedure with name n and parameters p\n"
".endmacro        Ends a <#QU>.macro<#NM> assembler definition\n"
".incbin \"f\"      Include the contents of file f verbatim in the output\n"
".include \"f\"     Include a 6502 assembler file for assembly at this point\n"
".string \"s\"      Insert the string s into the output\n"
".strcode         Set a string character parser; an expression is applied to each character\n"
"\n"
"The following dot directives work with dot commands:\n"
"\n"
"<#TB>Directive        Meaning<#NM>\n"
".defined         Used with <#QU>.if<#NM> to test whether a macro parameter was specified\n"
".lt              Less than (<#QU><<#NM>)\n"
".le              Less than or equal (<#QU><=<#NM>)\n"
".gt              Greater than (<#QU>><#NM>)\n"
".ge              Greater than or equal (<#QU>>=<#NM>)\n"
".eq              Equal (<#QU>=<#NM> or <#QU>==<#NM>)\n"
".ne              Not equal (<#QU>!=<#NM> or <#QU><><#NM>)\n"
"\n"
"<#H3>Assembler Expressions<#NM>\n"
"The assembler has a full expression parser. The following table lists valid tokens and illustrates their order of precedence:\n"
"\n"
"<#TB>Token                               Description<#NM>\n"
"<#QU>*<#NM>, <#QU>:<#NM>, <#QU>Num<#NM>, <#QU>variables<#NM>, <#QU>(<#NM>   Address, anonymous labels, numbers, variables, and brackets\n"
"<#QU>+<#NM>, <#QU>-<#NM>, <#QU><<#NM>, <#QU>><#NM>, <#QU>~<#NM>             Unary plus, minus, low byte, high byte, and bitwise not\n"
"<#QU>**<#NM>                                Exponentiation\n"
"<#QU>*<#NM>, <#QU>/<#NM>, <#QU>%<#NM>                       Multiply, divide, and modulus\n"
"<#QU>+<#NM>, <#QU>-<#NM>                            Addition and subtraction\n"
"<#QU><<<#NM>, <#QU>>><#NM>                          Shift left and shift right\n"
"relational                          <#QU>.lt .le .gt .ge<#NM> for <#QU><, <=, >, >=<#NM>\n"
"equality                            <#QU>.ne .eq<#NM> for <#QU>!=, ==<#NM>\n"
"<#QU>&<#NM>                                 Bitwise AND\n"
"<#QU>^<#NM>                                 Bitwise exclusive OR\n"
"<#QU>\\ <#NM>                                Bitwise OR\n"
"<#QU>&&<#NM>, <#QU>\\\\ <#NM>                        Logical AND and OR\n"
"<#QU>?<#NM>, <#QU>:<#NM>                            Ternary conditional\n"
"\n"
"<#H3>Assembler Numbers<#NM>\n"
"Numbers can be written in the following formats:\n"
"\n"
"<#TB>Prefix    Base<#NM>\n"
"<#QU>$<#NM>       Hexadecimal number. $ followed by 1 to 4 digits\n"
"<#QU>0<#NM>       Octal number. 0 followed by digits in the range 0..7\n"
"<#QU>%%<#NM>       Binary number. % followed by didgts 0 or 1 only\n"
"<#QU>1<#NM>-<#QU>9<#NM>   Decimal number.\n"
"\n"
"Inside strings, numbers can also be quoted. In that case, the formats are:\n"
"\n"
"<#TB>Prefix        Base<#NM>\n"
"<#QU>\\x[N]+<#NM>      Hexadecimal number. The same rules apply as in the previous table\n"
"<#QU>\\0[N]+<#NM>      Octal\n"
"<#QU>%%[1|0]+<#NM>   Binary\n"
"<#QU>[0-9]+<#NM>     Decimal\n"
"\n"
"<#H3>Assembler Variables<#NM>\n"
"Variables can be followed by assignment (<#QU>=<#NM>), increment (<#QU>++<#NM>), and decrement (<#QU>--<#NM>) operators. Although this looks like postfix C notation, it is actually executed as a prefix operator. For example:\n"
"<#QU>\n"
"i = 0\n"
"lda #i++\n"
"<#NM>\n"
"This will not load A with 0, but with 1.\n"
"\n"
"NOTE: The address character <#QU>*<#NM> is intentionally returned as +1 from where it is read. This means:\n"
"<#QU>\n"
"* = $8000\n"
"a = *    ; a will now be $8001\n"
": b = :- ; but b will be $8000\n"
"<#NM>\n"
"The reason is that in statements such as <#QU>lda *<#NM>, the instruction has not yet been emitted when <#QU>*<#NM> is evaluated, so reading <#QU>*<#NM> adds one. Using <#QU>a = * - 1<#NM> is also valid.\n"
"\n"
"<#H3>Assembler Ternary<#NM>\n"
"Like C, the ternary conditional has the form:\n"
"<#QU>(condition expression) ? (when true expression) : (when false expression)<#NM>\n"
"\n"
"In its simplest form:\n"
"<#QU>\n"
"1: i = 1 ? 2 : 3\n"
"; i is assigned 2, since 1 is true\n"
"<#NM>\n"
"A slightly more complex example:\n"
"<#QU>\n"
"2: i = j .eq 1 ? 4 : j .eq 2 ? 5 : 6\n"
"; if j == 1, i = 4\n"
"; else if j == 2, i = 5\n"
"; otherwise, i = 6\n"
"<#NM>\n"
"Any valid expression, no matter how complex, is allowed in each of the three clauses.\n"
"\n"
"<#H3>Assembler For Loops<#NM>\n"
"The assembler for-loop syntax is useful for tasks such as creating data tables:\n"
"<#QU>\n"
".for <initialization>, <condition>, <iteration>\n"
"    ; body\n"
".endfor\n"
"<#NM>\n"
"Example:\n"
"<#QU>\n"
"rowL:\n"
"    .for row=0, row .lt $C0, row++\n"
"        .byte   (row & $08) << 4   (row & $C0) >> 1   (row & $C0) >> 3\n"
"    .endfor\n"
"\n"
"rowH:\n"
"    .for row=0, row .lt $C0, row++\n"
"        .byte   >$2000   (row & $07) << 2   (row & $30) >> 4\n"
"    .endfor\n"
"<#NM>\n"
"The <#QU>row++<#NM> could also be written as <#QU>row = row + 1<#NM>. Any valid expression may be used in any clause. If a loop fails to terminate (that is, the condition is never false), the assembler automatically stops after 64K iterations.\n"
"\n"
"Note that in <#QU>rowH<#NM>, the high byte of <#QU>$2000<#NM> is <#QU>$20<#NM>, which is ORed with the other expressions. The order of operations does not cause <#QU>|<#NM> to occur before <#QU>><#NM>. If it did, the output would simply be <#QU>$20<#NM>, as the low-byte data would be discarded. Shift operators (<#QU><<<#NM>, <#QU>>><#NM>) have higher precedence than bitwise AND (<#QU>&<#NM>), so parentheses are required. The overall precedence rules match those of the C language.\n"
"\n"
"<#H3>Assembler Macros<#NM>\n"
"Macros have the form:\n"
"<#QU>\n"
".macro <name> [arg [, arg]*]\n"
" <macro body>\n"
".endmacro\n"
"<#NM>\n"
"Arguments are variables. For example:\n"
"<#QU>\n"
".macro add_a_b a b\n"
"    clc\n"
"    lda a\n"
"    adc b\n"
".endmacro\n"
"\n"
"    add_a_b 12, 25 ; This is a call to use the macro\n"
"<#NM>\n"
"This emits:\n"
"<#QU>\n"
"    clc\n"
"    lda 12\n"
"    adc 15\n"
"<#NM>\n"
"Note the lack of <#QU>#<#NM>. You cannot call the macro with <#QU>add_a_b #12, #25<#NM>, since <#QU>#12<#NM> is not a valid variable value. The <#QU>#<#NM> must be part of the macro body. This macro system is not yet very powerful, but it helps reduce repetition.\n"
"\n"
"<#H3>Assembler Strcode<#NM>\n"
"<#QU>.strcode<#NM> maps characters in a string to other values. It uses the variable <#QU>_<#NM> to perform the mapping. For example, <#QU>.string \"Apple ][ Forever\"<#NM> produces the output <#QU>41 70 70 6C 65 20 5D 5B 20 46 6F 72 65 76 65 72<#NM>, whereas:\n"
"<#QU>\n"
".strcode _ .ge 'A' && _ .le 'Z' ? _ - 'A' : _ .ge 'a' && _ .le 'z' ? _ - 'a' : _\n"
".string \"Apple ][ Forever\"\n"
"<#NM>\n"
"produces the output <#QU>00 0F 0F 0B 04 20 5D 5B 20 05 0E 11 04 15 04 11<#NM>.\n"
"As can be seen, the ASCII alphabet characters were remapped to the 0..25 range, but the spaces and <#QU>][<#NM> characters were left alone.\n"
"\n"
"To disable processing, use <#QU>.strcode _<#NM>. Note that if you use <#QU>_<#NM> as a variable elsewhere, <#QU>.strcode<#NM> will overwrite it.\n"
"\n"
"<#H2>Assembler Sample<#NM>\n"
"The sample folder contains code for use with the assembler. The <#QU>Manic Miner<#NM> folder contains the full source code for the Manic Miner game, and most of the constructs discussed above are used there.\n"
"\n"
"There is also a Python script to help de-scope ca65 assembler source files. This is how the Manic Miner sources were created.\n"
,
"<#H0>INI Files in Depth<#NM>\n"
"a2m uses INI files to configure itself at startup. The sequence is to read the INI file specified on the command line, or, if none is specified, to read <#QU>a2m.ini<#NM> in the current folder. This is unless <#QU>--noini<#NM> was specified, in which case an INI file is not read. After reading the INI file, a2m will apply any command-line switches that affect configuration to the configuration loaded from the INI file.\n"
"\n"
"This means the on-disk INI file can be altered by the command line. This can be prevented by specifying the <#QU>--nosaveini<#NM> command-line switch. When <#QU>--nosaveini<#NM> is specified, the INI file is not saved on exit, even if the INI file that was parsed contained a switch to save on exit, or <#QU>--saveini<#NM> was specified. <#QU>--saveini<#NM> is used to force saving to an INI file that does not contain a switch to save on exit. This is a way to force a command-line change into an on-disk INI file.\n"
"\n"
"All section headings appear between square brackets, for example <#QU>[Machine]<#NM>. The names are case-insensitive. All variables in a section have the form <#QU><Name> = <value><#NM>, where <#QU><Name><#NM> is the name of the variable and <#QU><value><#NM> is the value associated with that variable.\n"
"\n"
"Comments can be used in INI files, but note that if a2m saves out an INI file, the comments will be lost. Comments take the form <#QU># Everything after the hash symbol (#) is a comment<#NM>. Comments can appear on lines that also have valid information, for example: <#QU>Variable = Value # assign Value to Variable<#NM>.\n"
"\n"
"<#H1>Machine Section<#NM>\n"
"The Machine section is used to configure the Apple 2 machine that is being emulated. Variables are:\n"
"\n"
"<#TB>Variable   Value<#NM>\n"
"Model      <#QU>plus<#NM> or <#QU>enh<#NM>. <#QU>plus<#NM> emulates a ][+, and <#QU>enh<#NM> emulates a //e Enhanced\n"
"Turbo      Comma-separated values as 1 MHz multipliers. <#QU>max<#NM> for as fast as possible\n"
"\n"
"An example Turbo setting might be <#QU>Turbo = 1, 8, max ; This means 1 MHz, 8 MHz, or as fast as possible at 60 FPS<#NM>.\n"
"\n"
"<#H1>Config Section<#NM>\n"
"The Config section is mostly UI configuration. Variables are:\n"
"\n"
"<#TB>Variable       Value<#NM>\n"
"disk_leds      Value <#QU>on<#NM> or <#QU>1<#NM> shows disk activity LEDs in the lower right of the UI\n"
"save           <#QU>yes<#NM> means save the INI file on exit\n"
"symbols        Comma-separated files that contain symbol information\n"
"wheel_speed    Number of lines to scroll when using the mouse scroll wheel\n"
"\n"
"<#H1>Video Section<#NM>\n"
"The Video section has only one valid variable, and it is only used to configure the 80-column card on the Apple ][+ model. Using this will install the Franklin Ace Display card into a slot on an Apple ][+ machine.\n"
"\n"
"<#TB>Variable   Value<#NM>\n"
"sNdev      Franklin Ace Display. The <#QU>N<#NM> in <#QU>sNdev<#NM> is a slot number, usually 3\n"
"\n"
"<#H1>DiskII Section<#NM>\n"
"The Disk II section configures an Apple Disk II floppy drive.\n"
"\n"
"<#TB>Variable   Value<#NM>\n"
"sNdX       Comma-separated paths to floppy disk images\n"
"\n"
"The <#QU>N<#NM> and <#QU>X<#NM> in <#QU>sNdX<#NM> are slot and drive numbers. The slot is usually 6, and the drive number can be <#QU>0<#NM> or <#QU>1<#NM>.\n"
"\n"
"Example:\n"
"<#QU>s6d0 = \"./disks/Leaderboard side A.nib\",\"./disks/Leaderboard side B.nib\"<#NM>\n"
"\n"
"In the example, both floppy disk images are configured for a Disk II in slot 6, drive 0. Side A will be mounted, and using the Swap button in the UI, or the Swap action in a breakpoint, the Side B floppy can be swapped into the drive for use.\n"
"\n"
"<#H1>SmartPort Section<#NM>\n"
"The SmartPort section configures a slot for use as a SmartPort block device. These contain block device images, usually 32 MB images (often 33,553,920 bytes) or smaller.\n"
"\n"
"<#TB>Variable   Value<#NM>\n"
"sNdX       Path to a disk image\n"
"bs         A value of <#QU>1<#NM> will force-boot that device\n"
"\n"
"As with the Disk II section, the values for <#QU>N<#NM> and <#QU>X<#NM> are a valid, unused slot number and device number, where device numbers are <#QU>0<#NM> or <#QU>1<#NM>. Usually the slot numbers are <#QU>5<#NM> or <#QU>7<#NM>. The Apple //e will try to boot from a SmartPort device <#QU>0<#NM> in slot <#QU>7<#NM>. The <#QU>bs<#NM> setting can be used to force an Apple 2 to boot a SmartPort device <#QU>0<#NM> in a slot other than slot <#QU>7<#NM>, or to boot an Apple ][+ from a SmartPort device instead of the Disk II device.\n"
"\n"
"<#H1>Debug Section<#NM>\n"
"The Debug section is not a normal INI section. Normally, a variable (or key, in INI parlance) must have a unique name. In the Debug section, the <#QU>break<#NM> variable is used repeatedly.\n"
"\n"
"The <#QU>break<#NM> variable takes the form:\n"
"<#QU>break = <address[-address]>[,<pc read write access reset fast slow swap sNdX tron troff type str count[,reset]><#NM>\n"
"\n"
"In this syntax, elements in <#QU><><#NM> are required, and elements in <#QU>[]<#NM> are optional. When <#QU>|<#NM> is used, it means \"or\". For example, <#QU>[,pc read write]<#NM> means an optional comma followed by one of <#QU>pc<#NM>, <#QU>read<#NM>, or <#QU>write<#NM>.\n"
"\n"
"<#H0>* <#BO>address<#NM> is the breakpoint address, usually a hexadecimal number such as <#QU>0x1234<#NM>.\n"
"<#H0>* <#BO>-address<#NM> is optional and makes the breakpoint apply to a range from address to address. This takes the form <#QU>0x8000-0x80ff<#NM>, where <#QU>0x8000<#NM> is the range start and <#QU>0x80ff<#NM> is the range end.\n"
"<#H0>* <#BO>pc<#NM> means this is a breakpoint on code execution.\n"
"<#H0>* <#BO>read<#NM> means the breakpoint is activated by a read from the address or range.\n"
"<#H0>* <#BO>write<#NM> means the breakpoint is activated by a write to the address or range.\n"
"<#H0>* <#BO>access<#NM> means the breakpoint is activated by either a read from or a write to the address or range.\n"
"<#H0>* <#BO>fast<#NM> sets Turbo Mode to <#QU>max<#NM>.\n"
"<#H0>* <#BO>slow<#NM> sets Turbo Mode to 1 MHz.\n"
"<#H0>* <#BO>restore<#NM> sets Turbo Mode back to the value it had before <#QU>slow<#NM> or <#QU>fast<#NM> was used.\n"
"<#H0>* <#BO>swap<#NM> swaps the disk in the drive (Slot N Drive X) to the next disk in the queue.\n"
"<#H0>* <#BO>tron<#NM> turns trace logging on. The log is written to the file <#QU>trace.txt<#NM> in the current folder.\n"
"<#H0>* <#BO>troff<#NM> turns trace logging off.\n"
"<#H0>* <#BO>type<#NM> inserts the characters from <#QU>str<#NM> into the keyboard address.\n"
"<#H0>* <#BO>count<#NM> is a number that sets the breakpoint counter to that value.\n"
"<#H0>* <#BO>reset<#NM> is a number that sets the breakpoint reset counter to that value.\n"
"\n"
"For <#QU>count<#NM> and <#QU>reset<#NM>, the first non-keyword number is assumed to be <#QU>count<#NM>, and the second is <#QU>reset<#NM>.\n"
"\n"
"Here are a few examples:\n"
"\n<#QU>"
"; switch to the second floppy for Disk II in slot 6, drive 0\n"
"break = 0x55b5,swap=s6d0\n"
"; press enter\n"
"break = 0x55b8,type=\r\n"
"; set Turbo Mode to fast, that is, as fast as possible at 60 FPS (max)\n"
"break = 0x581e,fast\n"
"; after 10 read/write accesses in the range, a break will occur\n"
"; thereafter, every second access will cause a break\n"
"break = 0x5000-0x5002,access,10,2\n"
"<#NM>"
};