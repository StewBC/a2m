// Apple ][+ and //e Enhanced emulator with assembler
// Stefan Wessels, 2025
// This is free and unencumbered software released into the public domain.

// NM = #D0D0D0
// BG = #D2D2D2
// H0 = #00B7FF
// H1 = #00E5A8
// H2 = #FFD84D
// H3 = #B388FF
// BO = #AB1D2B
// QU = #FF9F43
// TB = #FF6B6B

const int unk_help_page_count = 9;

const char *unk_page_titles[] = {
    "Intro",
    "Debug",
    "DASM View",
    "Mem View",
    "Misc View",
    "Dialogs",
    "Assembler",
    "INI Files",
    "History",
};

const char *unk_help_text[] = {
"<#H0>Quick Key Reference<#NM>\n"
"In both Normal and Debug Mode, these keys have the listed meanings:\n"
"\n"
"<#TB>Key           Action                        Key           Action<#NM>\n"
"F1            Show Help                     F2            Toggle Debug Mode View\n"
"F3            Toggle Turbo Mode             F4\n"
"F5            Run                           F6            Run to cursor\n"
"F7                                          F8\n"
"F9            Toggle Breakpoint             F10           Step\n"
"F11           Break                         F12           Monitor Select\n"
"CTRL+F2       CTRL+Reset                    ALT+F2        CTRL+OpenApple+Reset\n"
"CTRL+SHIFT+F4 Configure Assembler           CTRL+F4       Run Assembler\n"
"CTRL+F5       Insert from clipboard         SHIFT+F11     Step Out\n"
"                                            SHIFT+F12     Toggle Franklin Ace Display in a <#QU>][+<#NM>\n"
"\n"
"Debug Mode (<#QU>F2<#NM>) also reveals the Miscellaneous view, and it is here where disks can be inserted, making the Apple 2 really useful.\n"
"\n"
"<#H0>Running a2m<#NM>\n"
"a2m can be launched from the command line or as a GUI application without a console window.\n"
"\n"
"<#H1>Command Line<#NM>\n"
"Running a2m is as simple as executing the program with any desired switches.\n"
"Use <#QU>--help<#NM> (or <#QU>-h<#NM>) to view the full command-line reference.\n"
"\n"
"<#H1>INI Files<#NM>\n"
"a2m supports configuration through INI files. They are optional but handy for storing common setups (for example, per-game configurations).\n"
"\n"
"Use <#QU>--inifile <file><#NM> (or <#QU>-i <file><#NM>) to load a specific INI file at launch.\n"
"By default, a2m loads <#QU>a2m.ini<#NM> from the current directory.\n"
"\n"
"See <#QU>INI Files in Depth<#NM> for full details.\n"
"\n"
"<#H0>User Interface<#NM>\n"
"a2m is primarily a GUI-based Apple 2 emulator. It also supports a text-based mode, enabled with <#QU>--ui text<#NM> (or <#QU>-u text<#NM>). This mode exists mostly as a demonstration of the cleaner architecture introduced after v1.0.\n"
"\n"
"The text mode emulator runs Apple 2 text-based software in 40 or 80 columns in a terminal window. On Windows it opens a new terminal window (I could not get curses input connected to the existing terminal if launched that way) but on a Unix-style OS it runs in the launch terminal.\n"
"\n"
"Should the Apple 2 enable a graphics mode, the text-based emulator will simply draw a box and label it as LOWRES, HGR, DOUBLE LOWRES or DOUBLE HIRES. For mixed modes you will see the box in the upper portion of the screen and the normal text in the lower portion.\n"
"\n"
"This mode works well when booting ProDOS with Bitsy Bye, for example.\n"
"\n"
"On a Unix-style OS, CTRL-C will quit the emulator, so there are meta-keys to press for CTRL and Open- and Close-Apple. Press F1 in the emulator to see a Key Quick Reference. Note that the debugger is not available in the text mode emulator. It is only for running text-based Apple 2 applications.\n"
"\n"
"The text mode emulator will not be discussed any further.\n"
"\n"
"<#H0>Normal Mode<#NM>\n"
"When launched normally, a2m displays the Apple 2's video output in the full application window. It behaves like a ][+ or //e.\n"
"The Apple 2 will attempt to boot from:\n"
"\n"
"<#BO>* <#QU>Slot 6 Drive 0<#NM> (floppy), or\n"
"<#BO>* <#QU>Slot 7 Device 0<#NM> (hard-disk image)\n"
"\n"
"These defaults can be overridden in an INI file.\n"
"\n"
"<#H1>Keyboard Usage<#NM>\n"
"Regular keys are sent directly to the emulated Apple 2. Function keys control the debugger, which is always running \"behind the scenes\" even when the Apple 2 display fills the window.\n"
"\n"
"On the //e model:\n"
"\n"
"<#BO>* <#QU>Open-Apple<#NM> - joystick button A or Left-ALT\n"
"<#BO>* <#QU>Closed-Apple<#NM> - joystick button B or Right-ALT\n"
"\n"
"To paste text into the Apple 2, use <#QU>SHIFT+INSERT<#NM>.\n"
"<#QU>PAUSE<#NM> acts as RESET. Some laptops require combinations such as <#QU>Fn+B<#NM> or <#QU>Fn+P<#NM>.\n"
"\n"
"<#QU>F1<#NM> opens a help screen and pauses emulation.\n"
"All other function keys remain debugger controls even while in Normal Mode.\n"
"\n"
"<#H1>Resizing<#NM>\n"
"The window can be resized using standard OS controls.\n"
"The Apple 2 display is always drawn within the largest 4:3 region that fits inside the window's client area.\n"
"\n"
,
"<#H0>Debug Mode<#NM>\n"
"Debug Mode is where a2m really shines. Every part of the emulated Apple 2 can be inspected, and many parts can be modified.\n"
"\n"
"Although Debug Mode is often described as a separate mode, it is always active. All function keys route to the debugger even when only the Apple 2 display is visible. Once the debugger views are shown, the full set of tools becomes available.\n"
"\n"
"<#H1>Opening the Debugger<#NM>\n"
"Press <#QU>F2<#NM> to open the Debug Mode View. Press <#QU>F2<#NM> again to hide it. The following table represents the layout of the Debugger Views, when opened.\n"
"\n"
"<#TB>Position             View<#NM>\n"
"Upper left:          Apple 2 display\n"
"Upper right:         CPU view\n"
"Right, below         CPU: Disassembly view\n"
"Lower left:          Memory view (hex + text; any bank can be inspected)\n"
"Lower right:         Miscellaneous view (slot configuration, disks, soft-switches, breakpoints, etc.)\n"
"\n"
"<#H1>Basic UI Philosophy<#NM>\n"
"a2m uses the <#QU>Nuklear<#NM> immediate-mode GUI library. Nuklear uses a *hover-active* model: when the CPU is stopped, whichever view the mouse is over becomes active and receives input. Active views have a green header; inactive ones use grey.\n"
"\n"
"When the emulator is running, all keys except function keys and SHIFT+INSERT go to the Apple 2.\n"
"\n"
"In the rest of this manual, \"in Debug Mode\" is omitted for brevity-assume Debug Mode unless noted.\n"
"\n"
"The debugger layout is resizable:\n"
"\n"
"<#BO>*<#NM> a <#QU>vertical slider<#NM> between the Apple 2 and the CPU/Disassembly views\n"
"<#BO>*<#NM> a <#QU>horizontal slider<#NM> between the Apple 2 and the Memory/Misc views\n"
"\n"
"Dragging these sliders resizes the layout.\n"
"A \"hot spot\" in the lower-right corner of the Apple 2 view moves both sliders together, scaling the layout proportionally.\n"
"If the Apple 2 view is letterboxed, clicking this hot spot snaps it back to a perfect 4:3 region.\n"
"\n"
"<#H1>Apple 2 View<#NM>\n"
"As in Normal Mode, the Apple 2 display is always shown in a 4:3 region inside the largest area available.\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"When the emulator is running, regular keys go to the Apple 2, while function keys and SHIFT+INSERT always go to the debugger.\n"
"\n"
"See <#QU>Disassembly View - Keyboard controls<#NM> for details on function-key behaviour.\n"
"\n"
"<#H1>CPU View<#NM>\n"
"The CPU view shows the program counter (PC), stack pointer (SP), registers, and flags.\n"
"When the emulator is stopped, these can be edited by typing new values:\n"
"\n"
"<#BO>*<#NM> PC and SP: 16-bit hex\n"
"<#BO>*<#NM> Registers: 8-bit hex\n"
"<#BO>*<#NM> Flags: 0 (off) or 1 (on)\n"
"\n"
"Flags are:\n"
"\n"
"<#BO>* <#QU>N<#NM> - Negative\n"
"<#BO>* <#QU>V<#NM> - oVerflow\n"
"<#BO>* <#QU>E<#NM> - ignorEd\n"
"<#BO>* <#QU>B<#NM> - Break\n"
"<#BO>* <#QU>D<#NM> - Decimal mode\n"
"<#BO>* <#QU>I<#NM> - Interrupt\n"
"<#BO>* <#QU>Z<#NM> - Zero\n"
"<#BO>* <#QU>C<#NM> - Carry\n"
"\n"
,
"<#H1>Disassembly View<#NM>\n"
"The disassembly view shows the code being executed by the CPU. When running or stepping, the current instruction (at the PC) is highlighted. Other highlighted lines include:\n"
"\n"
"<#BO>*<#NM> the cursor\n"
"<#BO>*<#NM> any addresses with a <#QU>stop<#NM> breakpoint\n"
"  (breakpoints with non-stop actions do not appear highlighted)\n"
"\n"
"Each line follows this general format:\n"
"\n"
"<#QU>C27D: WAITKEY1      E6 4E       INC RNDL<#NM>\n"
"\n"
"Broken down:\n"
"\n"
"<#TB>Element       Meaning<#NM>\n"
"C27D          The hexadecimal address in RAM\n"
"WAITKEY1      A label for that address (if present)\n"
"E6 4E         The raw bytes at the address at the start of the line\n"
"INC RNDL      The disassembled instruction (with symbols resolved when available)\n"
"\n"
"See <#QU>Symbols Dialog<#NM> for more information.\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"These keys apply <#QU>when emulation is stopped<#NM>:\n"
"\n"
"<#TB>Key           Action<#NM>\n"
"C+a           Edit the memory address of the cursor line\n"
"C+S+b         Open the Assembler Configuration Dialog\n"
"C+b           Assemble the configured source file\n"
"C+e           Show the assembler errors dialog\n"
"C+p           Set the PC to the cursor address\n"
"C+s           Open the symbol lookup dialog\n"
"ENTER         Finish \"edit memory address\" mode\n"
"TAB           Cycle through lookup, syms & labels; syms & labels; labels; or raw\n"
"HOME          Move the cursor to the top of the view\n"
"C+HOME        Jump to address <#QU>$0000<#NM>\n"
"END           Move the cursor to the last line of the view\n"
"C+END         Jump to address <#QU>$FFFF<#NM>\n"
"UP/DOWN       Move the cursor, scrolling if needed\n"
"LEFT          Scroll to show the cursor\n"
"C+LEFT        Set PC to cursor and scroll to it\n"
"RIGHT         Scroll to show the PC\n"
"C+RIGHT       Set cursor to PC and scroll to it\n"
"PAGE UP       Page up by one full view\n"
"PAGE DOWN     Page down by one full view\n"
"\n"
"<#QU>C+ and S+ mean CONTROL+ and SHIFT+, respectively.<#NM>\n"
"\n"
"<#H2>Mouse Controls<#NM>\n"
"At the bottom of the view are <#QU>selector buttons<#NM> that choose which memory bank to display.\n"
"On the Apple ][+ model, the 128 K option is disabled.\n"
"\n"
"<#TB>Label         Action<#NM>\n"
"6502          Shows the CPU's current live memory map\n"
"64K           Shows the first 64 K regardless of soft-switch configuration\n"
"128K          On the //e, shows the auxiliary bank\n"
"LC Bank       Toggles between the two language-card banks\n"
"\n"
"The <#QU>scrollbar<#NM> on the right scrolls from address <#QU>$0000<#NM> to <#QU>$FFFF<#NM>.\n"
"A mouse <#QU>scroll wheel<#NM> scrolls by 4 lines. Scroll sensitivity can be configured (see <#QU>INI Files in Depth - Config<#NM>).\n"
"\n"
"Click on any row, outside the address section, to put the cursor on that row. Click on the address section to set the address of that row (Same as pressing CTRL+a).\n"
"\n"
,
"<#H1>Memory View<#NM>\n"
"The memory view is a way of inspecting larger areas of the Apple 2 RAM. The display shows rows of memory in the format:\n"
"\n"
"<#QU>0000: 54 68 69 73 20 69 73 20 41 53 43 49 49 00 00 00 This is ASCII...<#NM>\n"
"\n"
"Broken down:\n"
"\n"
"<#TB>Element       Meaning<#NM>\n"
"0000          The hexadecimal address in RAM\n"
"54 68 ..      The bytes starting at the address at the start of the line\n"
"This is ..    The ASCII representation of the bytes (<#QU>54<#NM> is <#QU>T<#NM>, <#QU>68<#NM> is <#QU>h<#NM>, etc.)\n"
"\n"
"<#H2>Keyboard controls<#NM>\n"
"These keys apply <#QU>when emulation is stopped<#NM>:\n"
"\n"
"<#TB>Key           Action<#NM>\n"
"0..9, a..f    In the HEX portion, type hexadecimal characters to edit the memory\n"
"ASCII         In the ASCII portion, type ASCII letters to set the memory\n"
"C+a           Edit the memory address of the cursor line\n"
"C+f           Open the find dialog box\n"
"C+n           Search forward for the find string (find next)\n"
"C+S+n         Search backward for the find string (find previous)\n"
"C+s           Open the symbol lookup dialog\n"
"C+t           Switch between Hex and ASCII editing\n"
"C+v           Split the view, up to 16 times, into independent sub-views\n"
"C+j           Join the sub-view with its neighbouring sub-view\n"
"A+UP          Switch to the sub-view above the current sub-view\n"
"A+DOWN        Switch to the sub-view below the current sub-view\n"
"ENTER         Finish \"edit memory address\" mode\n"
"HOME          Move the cursor to the start of the current line\n"
"C+HOME        Move the cursor to the top of the view\n"
"END           Move the cursor to the end of the current line\n"
"C+END         Move the cursor to the end of the last line of the view\n"
"UP/DOWN       Move the cursor up or down, scrolling if needed\n"
"C+UP/DOWN     Scroll the view one line up or down\n"
"LEFT/RIGHT    Move the cursor left or right, wrapping to previous/next row if needed\n"
"PAGE UP       Page up by one full view\n"
"PAGE DOWN     Page down by one full view\n"
"S+INSERT      Paste from the OS clipboard (HEX into address and HEX, ASCII into ASCII)\n"
"\n"
"<#QU>A+, C+ and S+ mean ALT+, CONTROL+ and SHIFT+, respectively.<#NM>\n"
"\n"
"<#H2>Mouse Controls<#NM>\n"
"The <#QU>scrollbar<#NM> on the right scrolls from address <#QU>$0000<#NM> to <#QU>$FFFF<#NM>.\n"
"A mouse <#QU>scroll wheel<#NM> scrolls by 4 lines. Scroll sensitivity can be configured (see <#QU>INI Files in Depth - Config<#NM>).\n"
"\n"
"Click on any row, outside the address section, to place the cursor on that row. Click on the address section to set the address of that row (same as pressing CTRL+a).\n"
"\n"
"Right-click on a value in the hex address matrix to open a pop-up window that shows the last four program-counter addresses where the selected address was modified. The top entry is the most recent change, the change that resulted in the current value at this address. If an address in the pop-up is <#QU>$0000<#NM>, it means that fewer than four changes to this address were recorded. Select any of the four addresses in the pop-up to move the cursor to the corresponding line in the disassembly view.\n"
"\n"
,
"<#H1>Miscellaneous View<#NM>\n"
"The Miscellaneous View consists of sub-views that can be opened and closed at will. Each sub-view has a triangle to the left of its name; clicking the triangle opens or closes the sub-view. The Miscellaneous View also has a scrollbar on the right, making it possible to see all details without closing any sub-views.\n"
"\n"
"The sub-views are:\n"
"\n"
"<#TB>View Name            Contents<#NM>\n"
"Slots                Devices inside the Apple 2 slots, such as Disk II or SmartPort cards\n"
"Debugger             Cycle counters, call stack, breakpoints, etc.\n"
"Soft Switches        Memory locations in the $C000-$C0FF range that affect Apple 2 operations\n"
"\n"
"Each of these is discussed in more detail below.\n"
"\n"
"<#H2>Slots Misc View<#NM>\n"
"The Slots view shows the hardware installed in the slots of the Apple 2. It is also the panel used for working with disks, both SmartPort and floppy.\n"
"\n"
"With both SmartPort and floppy devices, there are a few buttons exposed. Next to Disk or Device 0, there is a button with the slot number, a dot, and a zero. Next to that is an Eject button, followed by an Insert button. The display looks something like this:\n"
"\n"
"<#QU>\n"
"Slot 5: Smartport\n"
"[5.0][Eject][Insert]\n"
"Slot 6: Disk II\n"
"[6.0][Eject][Insert]\n"
"<#NM>\n"
"\n"
"\n"
"Clicking Insert opens the file browser, and if an appropriate file is selected (NIB for Disk II and any file for SmartPort), the file name is shown to the right of the Insert button. For a Disk II device, more than one file can be inserted. When this is done, a new button appears, labelled Swap. The button also indicates which disk is currently inserted (from the sequence) and how many disks are in the sequence. This looks like:\n"
"\n"
"<#QU>[6.0][Eject][Insert][Swap (1/2)] This is disk 1.po<#NM>\n"
"\n"
"The disk name, in this case, is \"This is disk 1.po\", and the button indicates that it is the first disk of two disks in the queue. Clicking the Swap button switches to the second disk, and the display might then look like this if the second disk is called \"This is disk 2.po\":\n"
"\n"
"<#QU>[6.0][Eject][Insert][Swap (2/2)] This is disk 2.po<#NM>\n"
"\n"
"Clicking Eject removes the currently selected disk from the drive and from the queue.\n"
"\n"
"Clicking the button labelled <#QU>[Slot.0]<#NM> boots the disk in drive/device 0 of that slot.\n"
"\n"
"<#H2>Debugger Misc View<#NM>\n"
"By default, the Debugger View shows status information under the heading <#QU>Debug Status<#NM>. This information is:\n"
"\n"
"<#TB>Name                 Description<#NM>\n"
"Run to PC nnnn       The button is selected when stepping over a JSR or using F6, and the\n"
"                     destination address is in nnnn. Otherwise, the button is unselected and\n"
"                     nnnn contains 0000\n"
"Step Out             The button is selected when F11 is used to step out of the current\n"
"                     subroutine\n"
"Step Cycles          The number of cycles between stops of the emulator. For example,\n"
"                     stepping over an INC of ZP will show 5 cycles, but stepping over a JSR\n"
"                     will show however many cycles the subroutine cost, plus the 6 JSR cycles\n"
"Total Cycles         Shows the total cycles since the emulator started running the\n"
"                     Apple 2 ROM code\n"
"\n"
"There is also a <#QU>Call Stack<#NM> display. This is a window with its own scrollbar if the entries exceed what the window can show. The call stack entries have the form:\n"
"\n"
"<#QU>E69E JSR FF59 OLDRST<#NM>\n"
"\n"
"Broken down:\n"
"\n"
"<#TB>Element              Meaning<#NM>\n"
"E69E                 The hexadecimal address where the JSR resides\n"
"JSR                  The instruction that caused the push onto the stack\n"
"FF59                 The destination address of the JSR, the address of the subroutine called\n"
"OLDRST               The symbol name for $FF59, from the loaded symbol files\n"
"\n"
"Note that clicking the address (<#QU>E69E<#NM> in this case) will set the disassembly view cursor to that address and show it in the disassembly view. The same is true for <#QU>FF59<#NM>; clicking it, or clicking to the right of the JSR, will place the disassembly cursor on that address and show it in the disassembly view.\n"
"\n"
"<#H3>Breakpoints<#NM>\n"
"The Debugger View has a breakpoints view that is only visible when at least one breakpoint is set. This view lists all configured breakpoints. Each breakpoint in this view has the format:\n"
"\n"
"<#QU>label [Edit][Disable][View PC][Clear]<#NM>\n"
"\n"
"The label describes the breakpoint. These are all possible label values, where nnnn is the address of the breakpoint:\n"
"\n"
"<#TB>Label                Meaning<#NM>\n"
"nnnn (counters)      Uses a counter\n"
"nnnn Fast            Sets the Turbo Mode to Fast\n"
"nnnn Restore         Restores the Turbo Mode to the value before it was set to Fast\n"
"nnnn Slow            Sets the Turbo Mode to Slow\n"
"nnnn Swap sxdy       Swaps the Disk II disk in Slot x Drive y to the next disk in the queue\n"
"nnnn Troff           Turns file trace logging off\n"
"nnnn Tron            Turns file trace logging on, to the file ./trace.txt\n"
"nnnn Type            Types keys on the Apple II keyboard (<#QU>\\r<#NM>, <#QU>123<#NM>, or <#QU>\\x0a<#NM>, for example)\n"
"z[Range]             Stop on specified access to an address in the range\n"
"z[Range] (counters)  Stop on specified access to an address in the range, subject to counters\n"
"z[nnnn]              Stop on specified access to an address\n"
"z[nnnn] (counters)   Stop on specified access to an address, subject to counters\n"
"\n"
"For type keys, the mechanism is similar to how paste works. When address <#QU>$C010<#NM> is accessed, another key is inserted into the <#QU>$C000<#NM> keyboard address for the Apple 2 to read. This is useful for pressing a key when, for example, there is a prompt that says \"Insert disk 2 and press enter\". Type can be used in conjunction with Swap to swap disk 2 in, press enter, and continue execution without user intervention.\n"
"\n"
"In the above table, these symbols mean:\n"
"\n"
"<#TB>Symbol               Meaning<#NM>\n"
"nnnn                 Hexadecimal memory location\n"
"(counters)           Takes the form (x/y), where x means the address has been accessed x times and\n"
"                     the stop will occur when x equals y\n"
"[Range]              Takes the form [xxxx-yyyy], where x and y are the start and end addresses of an\n"
"                     address range in which any access will count\n"
"z                    Represents R for read access, W for write access, and RW for read or write access\n"
"\n"
"<#BO>*<#NM> The <#QU>[Edit]<#NM> button opens the edit breakpoints dialog.\n"
"<#BO>*<#NM> The <#QU>[Disable]<#NM> button leaves the breakpoint in the list but ignores it. This is useful for leaving bookmarks in memory, as the <#QU>[View PC]<#NM> button will still jump to the location of that disabled breakpoint.\n"
"<#BO>*<#NM> The <#QU>[View PC]<#NM> button sets the disassembly view cursor to the nnnn address of the breakpoint and brings it into view.\n"
"<#BO>*<#NM> The <#QU>[Clear]<#NM> button deletes the breakpoint.\n"
"<#BO>*<#NM> When there is more than one breakpoint, a <#QU>[Clear All]<#NM> button appears at the top of the list to delete all breakpoints (including disabled ones).\n"
"\n"
"<#H2>Soft Switches Misc View<#NM>\n"
"The soft switches view shows the addresses of soft switches in the Apple //e (currently even in Apple ][+ mode). These are read-only, but there is a button to override the display switches. When the override is enabled, the interface does not change the hardware settings, but it behaves as though the hardware is set to the user settings from a UI perspective.\n"
"\n"
"For example, setting Mixed to ON will draw the Apple 2 screen as though Mixed is enabled. This is quite useful when drawing to an off-screen buffer. The override can be turned on and the off-screen buffer can be set as the visible buffer so that the drawing can be seen on-screen. When the display override is turned off, all switches return to showing their actual settings.\n"
"\n"
"Note that the addresses work in pairs, and only the first address is shown in the table. The odd address turns the setting on, and the even address turns the setting off. For example, <#QU>$C000<#NM> sets <#QU>80STORE<#NM> and <#QU>$C001<#NM> clears <#QU>80STORE<#NM>.\n"
"\n"
"<#TB>Address              Meaning<#NM>\n"
"C001 80STORE         ($C054/$C055) selects main vs aux independently of RAMRD/WRT for disp mem\n"
"C003 RAMRD           CPU reads aux $0200-$BFFF and LC $D000-$FFFF, see 80STORE\n"
"C005 RAMWRT          CPU writes aux $0200-$BFFF and LC $D000-$FFFF, see 80STORE\n"
"C007 CXROM           C100-CFFF //e ROM (overrides C3ROM and CFFF)\n"
"C009 ALTZP           ZP/stack are in aux bank\n"
"C00B C3ROM           Turn internal ROM off, turn Slot ROM on\n"
"C00D 80COL           80-column display (turn 80-col display on)\n"
"C00F ALTCHAR         alternate character set\n"
"C051 TEXT            Enable text mode\n"
"C053 MIXED           Graphics modes have 4 lines of text at the bottom\n"
"C055 PAGE2           Display from $800/$4000 instead of  $400/$2000\n"
"C057 HIRES           Enable high resolution graphics mode\n"
"C05E DHGR            Enable double resolution graphics mode\n"
"C08X LCBANK          Bank1 vs Bank2\n"
"C08X LCREAD          Show RAM vs ROM at $D000-$FFFF\n"
"C08X LCPREWRITE\n"
"C08X LCWRITE         Write to RAM at $D000-$FFFF\n"
"\n"
"The descriptions of the above are very loose. See a credible source for proper explanations.\n"
"\n"
,
"<#H1>Dialogs<#NM>\n"
"The dialog boxes are activated from various views and reused wherever needed in a2m.\n"
"\n"
"<#H2>File Browser Dialog<#NM>\n"
"This is a simple single-file selection dialog. A single mouse click is used to activate an action. The actions are <#QU>select a file<#NM> or <#QU>select a folder<#NM>. Selecting a folder enters that folder and updates the display to show the files and folders within it. The folder <#QU>..<#NM> is the parent of the current folder. Folders are sorted to the top of the dialog, followed by files.\n"
"\n"
"Press the <#QU>[OK]<#NM> button to close the dialog. If a file is highlighted when <#QU>[OK]<#NM> is pressed, that file becomes the selected file.\n"
"\n"
"<#H2>Breakpoint Editor<#NM>\n"
"The breakpoint editor dialog is used to change the way a breakpoint works. In it you can configure the address or address range that a breakpoint activates on, and whether that activation is on execution, read, write, or read or write. Actions can also be assigned to breakpoints here, as well as counters, as discussed in the Breakpoints section.\n"
"\n"
"The dialog has <#QU>Break At [nnnn] on [] PC [] Address Access<#NM>. In this, <#QU>nnnn<#NM> is the memory address to watch for an execution break if <#QU>on PC<#NM> is checked. If <#QU>Address Access<#NM> is checked, the breakpoint will activate on a read, write, or either. This depends on the checked state of <#QU>[] Read [] Write<#NM>, which is available if <#QU>Address Access<#NM> is chosen. Also available when <#QU>Address Access<#NM> is chosen is <#QU>[] Range<#NM>. Check <#QU>Range<#NM> to enter a second address. All selected accesses between the <#QU>Break At<#NM> and <#QU>Range<#NM> addresses will now cause a stop.\n"
"\n"
"The <#QU>Actions<#NM>:\n"
"\n"
"<#TB>Action  Meaning<#NM>\n"
"Break   Default action. Puts the emulator in a stopped state.\n"
"Fast    Switches the Turbo Mode to <#QU>max<#NM>.\n"
"Restore Switches the Turbo Mode to the last mode active through the <#QU>F3<#NM> setting\n"
"Slow    Switches the Turbo Mode to 1 MHz.\n"
"Swap    Enter the slot and drive, and a swap is done on that floppy.\n"
"Troff   Turns off trace file logging.\n"
"Tron    Turns on trace logging to a file called <#QU>./trace.txt<#NM>.\n"
"Type    Enter text to be \"typed\" into the Apple 2 when the breakpoint is hit\n"
"\n"
"Lastly, there is the <#QU>[] use Counter<#NM> setting. Select this option to enter two counter values. The first value is how many times the breakpoint must be hit before it causes its action, and the second value specifies what value to install as the counter once the breakpoint has been hit. As an example, setting <#QU>Counter<#NM> to 10 and <#QU>Reset Counter<#NM> to 2 means that the breakpoint must be hit 10 times before its action is executed, and after that it will only execute the action every second time the breakpoint is hit.\n"
"\n"
"Using <#QU>[Cancel]<#NM> will not apply any changes to the breakpoint, but pressing <#QU>[Apply]<#NM> will apply the changes to the breakpoint.\n"
"\n"
"<#H2>Symbols Dialog<#NM>\n"
"The symbol search dialog has a search box at the top and two buttons, <#QU>[OK]<#NM> and <#QU>[Cancel]<#NM>, at the bottom. In the middle is a list of names, addresses, and a symbol source name.\n"
"\n"
"Typing into the symbol search box performs a search on the name and the symbol source, and any matching symbols are shown in the middle section. For example, typing <#QU>PP<#NM> might show all symbols from the A<#QU>PP<#NM>LE2E source, as well as <#QU>A.TEMPP<#NM>T from the A2_BASIC source.\n"
"\n"
"Clicking on any line in the middle section, for example <#QU>A.TEMPPT $0052 A2_BASIC<#NM>, sets the Disassembly View cursor to address <#QU>$0052<#NM> and makes the cursor visible in the Disassembly View.\n"
"\n"
"Clicking <#QU>[OK]<#NM> closes the dialog.\n"
"\n"
"<#H2>Find Dialog<#NM>\n"
"The find dialog has selectors for string or hexadecimal searches. When searching for strings, type the ASCII characters to search for into the search box. When searching for hexadecimal values, type the hex values as two-digit hex numbers, not separated by any characters (for example <#QU>01abcd<#NM>), and press ENTER or click <#QU>[OK]<#NM>.\n"
"\n"
"Below the <#QU>[OK][Cancel]<#NM> buttons is a status string. This normally reads <#QU>Okay<#NM>. If, for example, you enter a search of <#QU>012<#NM> into the search field and press ENTER, the status message will indicate an error. In this case, the error would be <#QU>Uneven # of hex digits<#NM>, meaning that the number of hex digits must be even (pairs of two) for the search to work.\n"
"\n"
,
"<#H0>Using the Assembler<#NM>\n"
"In the section titled <#QU>Disassembly View<#NM>, it was shown how to set an assembler file to assemble (<#QU>CTRL+SHIFT+b<#NM>) and how to invoke the assembler (<#QU>CTRL+b<#NM>). In the following sections, the assembler is covered in more detail, including syntax and commands.\n"
"\n"
"In the remainder of the assembler documentation, 6502 means 6502 or 65C02, unless specifically stated otherwise.\n"
"\n"
"Note:\n"
"<#QU>*<#NM> There is a complete assembler sample in <#QU>./samples/mminer<#NM>.  The root file is <#QU>mminer-a2m.asm<#NM>.\n"
"\n"
"<#H1>Invoking from the command line<#NM>\n"
"The assembler can also be used stand-alone using the program <#QU>asm6502<#NM>. This is the same assembler used in the emulator, but with a command-line interface.\n"
"\n"
"The <#QU>asm6502<#NM> executable, when used with no command-line arguments, displays this help message:\n"
"<#QU>\n"
"Usage: asm6502.exe <-i infile> [-o outfile] [-s <symbolfile|->] [-v]\n"
"Where: infile is a 6502 assembly language file\n"
"       outfile will be a binary file containing the assembled 6502\n"
"       symbolfile contains a list all variables, labels and segment addresses\n"
"       symbolfile name as a '-' character sends output to stdout\n"
"       -v turns on verbose and will dump the generated hex 6502\n"
"<#NM>\n"
"\n"
"<#H1>Assembler Features and Syntax<#NM>\n"
"The assembler supports these features:\n"
"\n"
"<#TB>Feature              Description<#NM>\n"
"65x02 mnemonics      All standard opcodes and addressing modes\n"
"labels               Labels start with <#QU>a-z<#NM> or <#QU>_<#NM> and can contain numbers. A label ends with <#QU>:<#NM>\n"
"variables            Values can be assigned and used in expressions\n"
".commands            Dot commands are described below\n"
"comments             The comment character is <#QU>;<#NM> and everything after <#QU>;<#NM> on a line is ignored\n"
"address              The address character is <#QU>*<#NM> and it can be assigned and read\n"
"expressions          The assembler has a full expression parser\n"
"\n"
"There is a set of directives that control how a 6502 source file is assembled. These are referred to as <#QU>dot commands<#NM>, since each keyword starts with a <#QU>.<#NM> (period). The available <#QU>dot commands<#NM> are:\n"
"\n"
"<#TB>Command              Meaning<#NM>\n"
".6502                Only 6502 opcodes are valid. 65C02 opcodes are not valid and will cause errors\n"
".65c02               Both 6502 and 65C02 opcodes are valid\n"
".org n               Set the assembly location to address n. Another way to specify <#QU>* =<#NM>\n"
".addr                Synonym for <#QU>.word<#NM>\n"
".align v             Align to v bytes, inserting up to v-1 zeroes into the output\n"
".asciiz              <#QU>.string<#NM>, but at the end after all segments, emits a '\\0'\n"
".res l<#QU>[,b]<#NM>           Insert l bytes into the output, value <#QU>0<#NM> or the value of the optional <#QU>b<#NM>\n"
".byte b<#QU>[,b]*<#NM>         Insert b as a byte or bytes into the output - See Notes\n"
".word w<#QU>[,w]*<#NM>         Insert the word bytes w into the output\n"
".dword dw<#QU>[,dw]*<#NM>      Insert the double-word bytes dw into the output (low byte first)\n"
".qword qw<#QU>[,qw]*<#NM>      Insert the quad-word bytes qw into the output\n"
".drow w<#QU>[,w]*<#NM>         Insert the word bytes w into the output in reverse order\n"
".drowd dw<#QU>[,dw]*<#NM>      Insert the double-word bytes dw into the output in reverse order\n"
".drowq qw<#QU>[,qw]*<#NM>      Insert the quad-word bytes qw into the output in reverse order\n"
".if p                Conditional assembly where p is a condition such as <#QU>.if c .eq 1<#NM>\n"
".else                The else part of a conditional <#QU>.if<#NM> directive\n"
".endif               Ends a <#QU>.if<#NM> conditional assembler directive\n"
".for p               Start a loop where p has the form <#QU><initializer>, <condition>, <iteration><#NM>\n"
".endfor              Ends a <#QU>.for<#NM> loop assembler directive\n"
".repeat a<#QU>[,v]<#NM>        Repeat <#QU>[0-a)<#NM> times, setting the count in the optional variable <#QU>v<#NM>\n"
".endrepeat           Ends a <#QU>.repeat<#NM> assembler directive\n"
".endrep              Synonym for <#QU>.endrepeat<#NM>\n"
".macro n p           Start a macro procedure with name n and parameters p\n"
".local n             Creates a macro local variable or label with a unique numeric ID in format <#QU>__macro_local_XXXX<#NM>\n"
".endmacro            Ends a <#QU>.macro<#NM> assembler definition\n"
".incbin \"f\"          Include the contents of file f verbatim in the output\n"
".include \"f\"         Include a 6502 assembler file for assembly at this point\n"
".proc n              Open a procedure (which behaves the same as a named scope)\n"
".endproc             Closes the most recently opened named procedure\n"
".scope [n]           Open a named (n) scope, or an anonymous scope if no name (n) provided\n"
".endscope            Closes the most recently opened scope\n"
".segdef  \"n\",s[,e]   Define a named segment n, starting at s, and emit (default) or noemit\n"
".segment \"n\"         Activate the segment named n\n"
".string \"s\"          Insert the string s into the output\n"
".strcode e           Set a string character parser; the expression <#QU>e<#NM> is applied to each character\n"
"\n"
"Notes:\n"
"<#QU>*<#NM> Text in <#QU>[]<#NM> means optional and <#QU>[]*<#NM> means none or more\n"
"<#QU>*<#NM> The assembler runs in the folder of the input file, so includes must be relative to that folder.\n"
"<#QU>*<#NM> <#QU>.byte<#NM> can take strings as well, but note that <#QU>.strcode<#NM> will not run on those strings.\n"
"\n"
"The following dot directives work with dot commands:\n"
"\n"
"<#TB>Directive            Meaning<#NM>\n"
".defined             Used with <#QU>.if<#NM> to test whether a macro parameter was specified\n"
".lt                  Less than (<#QU><<#NM>)\n"
".le                  Less than or equal (<#QU><=<#NM>)\n"
".gt                  Greater than (<#QU>><#NM>)\n"
".ge                  Greater than or equal (<#QU>>=<#NM>)\n"
".eq                  Equal (<#QU>=<#NM> or <#QU>==<#NM>)\n"
".ne                  Not equal (<#QU>!=<#NM> or <#QU><><#NM>)\n"
"\n"
"<#H3>Assembler Expressions<#NM>\n"
"The assembler has a full expression parser. The following table lists valid tokens and illustrates their order of precedence:\n"
"\n"
"<#TB>Token                   Description<#NM>\n"
"<#QU>*<#NM>, <#QU>:<#NM>, <#QU>Num<#NM>, <#QU>variables<#NM>, <#QU>(<#NM> Address, anonymous labels, numbers, variables, and brackets\n"
"<#QU>+<#NM>, <#QU>-<#NM>, <#QU><<#NM>, <#QU>><#NM>, <#QU>~<#NM>           Unary plus, minus, low byte, high byte, and bitwise not\n"
"<#QU>**<#NM>                      Exponentiation\n"
"<#QU>*<#NM>, <#QU>/<#NM>, <#QU>%<#NM>                 Multiply, divide, and modulus\n"
"<#QU>+<#NM>, <#QU>-<#NM>                    Addition and subtraction\n"
"<#QU><<<#NM>, <#QU>>><#NM>                    Shift left and shift right\n"
"relational              <#QU>.lt .le .gt .ge<#NM> for <#QU><, <=, >, >=<#NM>\n"
"equality                <#QU>.ne .eq<#NM> for <#QU>!=, ==<#NM>\n"
"<#QU>&<#NM>                       Bitwise AND\n"
"<#QU>^<#NM>                       Bitwise exclusive OR\n"
"<#QU>|<#NM>                       Bitwise OR\n"
"<#QU>&&<#NM>, <#QU>||<#NM>                  Logical AND and OR\n"
"<#QU>?<#NM>, <#QU>:<#NM>                    Ternary conditional\n"
"\n"
"<#H3>Assembler Numbers<#NM>\n"
"Numbers can be written in the following formats:\n"
"\n"
"<#TB>Prefix               Base<#NM>\n"
"<#QU>$<#NM>                    Hexadecimal number. $ followed by 1 to 4 digits\n"
"<#QU>0<#NM>                    Octal number. 0 followed by digits in the range 0..7\n"
"<#QU>%<#NM>                    Binary number. % followed by digits 0 or 1 only\n"
"<#QU>1<#NM>-<#QU>9<#NM>                  Decimal number.\n"
"\n"
"Inside strings, numbers can also be quoted. In that case, the formats are:\n"
"\n"
"<#TB>Prefix               Base<#NM>\n"
"<#QU>\\x[N]+<#NM>               Hexadecimal number. The same rules apply as in the previous table\n"
"<#QU>\\0[N]+<#NM>               Octal\n"
"<#QU>\\%[1|0]+<#NM>             Binary\n"
"<#QU>\\[0-9]+<#NM>              Decimal\n"
"\n"
"<#H3>Assembler Variables<#NM>\n"
"Variables can be followed by assignment (<#QU>=<#NM>), increment (<#QU>++<#NM>), and decrement (<#QU>--<#NM>) operators. Although this looks like postfix C notation, it is actually executed as a prefix operator. For example:\n"
"<#QU>\n"
"i = 0\n"
"lda #i++\n"
"<#NM>\n"
"This will not load A with 0, but with 1.\n"
"\n"
"NOTE: The address character <#QU>*<#NM> is intentionally returned as +1 from where it is read. This means:\n"
"<#QU>\n"
"* = $8000\n"
"a = *    ; a will now be $8001\n"
": b = :- ; but b will be $8000\n"
"<#NM>\n"
"The reason is that in statements such as <#QU>lda *<#NM>, the instruction has not yet been emitted when <#QU>*<#NM> is evaluated, so reading <#QU>*<#NM> adds one. Using <#QU>a = * - 1<#NM> is also valid.\n"
"\n"
"<#H3>Assembler Ternary<#NM>\n"
"Like C, the ternary conditional has the form:\n"
"<#QU>(condition expression) ? (when true expression) : (when false expression)<#NM>\n"
"\n"
"In its simplest form:\n"
"<#QU>\n"
"1: i = 1 ? 2 : 3\n"
"; i is assigned 2, since 1 is true\n"
"<#NM>\n"
"\n"
"A slightly more complex example:\n"
"<#QU>\n"
"2: i = j .eq 1 ? 4 : j .eq 2 ? 5 : 6\n"
"; if j == 1, i = 4\n"
"; else if j == 2, i = 5\n"
"; otherwise, i = 6\n"
"<#NM>\n"
"\n"
"Any valid expression, no matter how complex, is allowed in each of the three clauses.\n"
"\n"
"<#H3>Assembler For Loops<#NM>\n"
"The assembler for-loop syntax is useful for tasks such as creating data tables:\n"
"<#QU>\n"
".for <initialization>, <condition>, <iteration>\n"
"    ; body\n"
".endfor\n"
"<#NM>\n"
"\n"
"Example:\n"
"<#QU>\n"
"rowL:\n"
"    .for row=0, row .lt $C0, row++\n"
"        .byte   (row & $08) << 4 | (row & $C0) >> 1 | (row & $C0) >> 3\n"
"    .endfor\n"
"\n"
"rowH:\n"
"    .for row=0, row .lt $C0, row++\n"
"        .byte   >$2000 | (row & $07) << 2 | (row & $30) >> 4\n"
"    .endfor\n"
"<#NM>\n"
"\n"
"The <#QU>row++<#NM> could also be written as <#QU>row = row + 1<#NM>. Any valid expression may be used in any clause. If a loop fails to terminate (that is, the condition is never false), the assembler automatically stops after 64K iterations.\n"
"\n"
"Note that in <#QU>rowH<#NM>, the high byte of <#QU>$2000<#NM> is <#QU>$20<#NM>, which is ORed with the other expressions. The order of operations does not cause <#QU>|<#NM> to occur before <#QU>><#NM>. If it did, the output would simply be <#QU>$20<#NM>, as the low-byte data would be discarded. Shift operators (<#QU><<<#NM>, <#QU>>><#NM>) have higher precedence than bitwise AND (<#QU>&<#NM>), so parentheses are required. The overall precedence rules match those of the C language.\n"
"\n"
"<#H3>Assembler Macros<#NM>\n"
"Macros have the form:\n"
"<#QU>\n"
".macro <name> [arg [, arg]*]\n"
"    ; macro body\n"
".endmacro\n"
"<#NM>\n"
"\n"
"Arguments are variables. For example:\n"
"<#QU>\n"
".macro add_a_b a b\n"
"    clc\n"
"    lda a\n"
"    adc b\n"
".endmacro\n"
"\n"
"    add_a_b 12, 25          ; This is a call to use the macro\n"
"    add_a_b \"($55),y\", #12  ; another call to use the macro with very different parameters\n"
"<#NM>\n"
"Notice that the <#QU>($55),y<#NM> is in quotation marks. Any parameter that contains a <#QU>,<#NM> must be completely wrapped in <#QU>\"<#NM> marks.\n"
"\n"
"This emits:\n"
"<#QU>\n"
"    clc\n"
"    lda 12\n"
"    adc 15\n"
"    clc\n"
"    lda ($55),y\n"
"    adc #12\n"
"<#NM>\n"
"\n"
"<#H3>Assembler Strcode<#NM>\n"
"<#QU>.strcode<#NM> maps characters in a string to other values. It uses the variable <#QU>_<#NM> to perform the mapping. For example, <#QU>.string \"Apple ][ Forever\"<#NM> produces the output <#QU>41 70 70 6C 65 20 5D 5B 20 46 6F 72 65 76 65 72<#NM>, whereas:\n"
"<#QU>\n"
".strcode _ .ge 'A' && _ .le 'Z' ? _ - 'A' : _ .ge 'a' && _ .le 'z' ? _ - 'a' : _\n"
".string \"Apple ][ Forever\"\n"
"<#NM>\n"
"produces the output <#QU>00 0F 0F 0B 04 20 5D 5B 20 05 0E 11 04 15 04 11<#NM>.\n"
"As can be seen, the ASCII alphabet characters were remapped to the 0..25 range, but the spaces and <#QU>][<#NM> characters were left alone.\n"
"\n"
"Note that quoted characters in strings do not have <#QU>.strcode<#NM> applied to them. In all strings, the escape sequences <#QU>\\n\\r\\t\\0<#NM> are interpreted as they are in C, and the backslash character itself must always be escaped as <#QU>\\\\<#NM>. The escape <#QU>\\0<#NM> represents zero, while <#QU>\\077<#NM> is an octal escape; consequently, <#QU>\\0<#NM> serves both purposes.\n"
"\n"
"To disable processing, use <#QU>.strcode _<#NM>. Note that if you use <#QU>_<#NM> as a variable in the same scope, <#QU>.strcode<#NM> will overwrite it.\n"
"\n"
"<#H3>Assembler Scope and proc<#NM>\n"
"The directives <#QU>.scope<#NM> and <#QU>.proc<#NM> define namespaces that allow the reuse of symbol names within a scope or procedure. For example:\n"
"<#QU>.proc A\n"
"start:\n"
"    lda $ffff\n"
".endproc\n"
"\n"
".proc B\n"
"start:\n"
"    sta A::start + 1\n"
".endproc\n"
"<#NM>\n"
"Here, <#QU>A::start<#NM> is distinct from <#QU>B::start<#NM>. The symbol name <#QU>start<#NM> may be reused freely within different scopes or procs without ambiguity. Note the syntax for accessing labels in other scopes: anchoring with <#QU>::<#NM> at the start of a name resolves the symbol from the root scope, while omitting the leading <#QU>::<#NM> resolves it relative to the current parent scope chain.\n"
"\n"
"Anonymous scopes are useful inside loops, for example:\n"
"<#QU>\n"
".for i=0, i .lt 8, i++\n"
"  .scope\n"
"    address = $C000 + (i << 4)\n"
"   start:\n"
"    lda address\n"
"  .endscope\n"
".endfor\n"
"<#NM>\n"
"In this example, anonymous scopes are generated with names <#QU>anon_0001<#NM> through <#QU>anon_0008<#NM>, assuming they are the first anonymous scopes declared within their parent scope.  Start has no name collision in the loop, as it is wrapped inside a scope.\n"
"\n"
"<#H3>Assembler .segdef and .segment<#NM>\n"
"The <#QU>.segdef<#NM> and <#QU>.segment<#NM> directives exist primarily to improve compatibility with ca65, making it easier to port ca65-based code. ca65 code frequently switches segments within a single assembly source file, and support for segments avoids the need to split such code into multiple files for the a2m assembler. In addition, non-emitting segments are useful even in native mode.\n"
"\n"
"As an example, consider the file <#QU>samples/mminer/mminer-a2m.asm<#NM>:\n"
"<#QU>\n"
".segdef \"ZEROPAGE\", $50, noemit\n"
".segdef \"LOWMEM\", $800, noemit\n"
".segdef \"HGR\", $4000\n"
".segdef \"CODE\", $6000\n"
".segdef \"RODATA\", $89DC\n"
".segdef \"DATA\", $BE40\n"
"\n"
".include \"mminer.asm\"\n"
"<#NM>\n"
"Named segments are created by <#QU>.segdef<#NM>. When a segment is activated using, for example, <#QU>.segment \"ZEROPAGE\"<#NM>, the code emit location is set to <#QU>$50<#NM>. Each instruction that would normally emit code advances the location counter, but because <#QU>ZEROPAGE<#NM> is marked <#QU>noemit<#NM>, no bytes are written.\n"
"\n"
"This allows zero-page memory to be laid out using directives such as <#QU>.res<#NM>, without requiring explicit address assignments. The assembler computes locations automatically, avoiding manual constructs such as <#QU>= $50<#NM>, <#QU>= $51<#NM>, and so on.\n"
"\n"
"Notes:\n"
"\n"
"* The assembler allows segments to overflow. For segments that are marked as <#QU>emit<#NM>, the assembler will issue a warning when overflow occurs and will report the amount by which a segment size must be adjusted to allow segments to abut correctly.\n"
"* Before the first <#QU>.segment<#NM> directive, native mode is active. In native mode, the address specified by <#QU>* =<#NM> or <#QU>.org<#NM> determines where code is emitted. After using <#QU>.segment<#NM>, native mode can be re-enabled with <#QU>.segment ""<#NM>.\n"
"\n"
"<#H3>Assembler and ca65<#NM>\n"
"The assembler was not written to be compatible with ca65, but the inclusion of <#QU>.proc<#NM>, <#QU>.scope<#NM>, and <#QU>.segment<#NM> significantly increases compatibility. Most of the <#QU>Manic Miner<#NM> sample code assembles without modification from the ca65 version. The following differences should be noted:\n"
"\n"
"<#QU>*<#NM> Expression evaluation order differs. a2m uses C-style operator precedence, while ca65 does not. For example, the expression <#QU>counter << 2 & 0xFF<#NM> will not produce the same result.\n"
"<#QU>*<#NM> a2m uses a <#QU>.for<#NM> loop construct and does not have a <#QU>.repeat<#NM> construct.\n"
"<#QU>*<#NM> a2m does not support quoted strings in <#QU>.byte<#NM> directives.\n"
"<#QU>*<#NM> In macros, a2m uses <#QU>.if .defined<#NM>, which is the inverse of ca65's <#QU>.ifblank<#NM>.\n"
"<#QU>*<#NM> Macros are not scoped in a2m; therefore, <#QU>.local<#NM> is not supported.\n"
"<#QU>*<#NM> In a2m, <#QU>:=<#NM> and <#QU>=<#NM> are equivalent.\n"
"<#QU>*<#NM> In a2m, reading the current address using <#QU>*<#NM> yields the address at that point in emission, not the start of the line. As a result, ca65 evaluates <#QU>lda #*<#NM> as <#QU>lda #0<#NM>, while a2m evaluates it as <#QU>lda #1<#NM> if the emitter address was 0 when the line was encountered.\n"
"\n"
"a2m lacks many of the advanced features found in ca65, but with what is there, a lot of code ports fairly easily to a2m now.\n"
"\n"
"<#H2>Assembler Sample<#NM>\n"
"The sample folder contains code for use with the assembler. The <#QU>samples/mminer<#NM> folder contains the full source code for the <#QU>Manic Miner<#NM> game, and most of the constructs discussed above are used there.\n"
"\n"
,
"<#H0>INI Files in Depth<#NM>\n"
"a2m uses INI files to configure itself at startup. The sequence is to read the INI file specified on the command line, or, if none is specified, to read <#QU>a2m.ini<#NM> in the current folder. This is unless <#QU>--noini<#NM> was specified, in which case an INI file is not read. After reading the INI file, a2m will apply any command-line switches that affect configuration to the configuration loaded from the INI file.\n"
"\n"
"This means the on-disk INI file can be altered by the command line. This can be prevented by specifying the <#QU>--nosaveini<#NM> command-line switch. When <#QU>--nosaveini<#NM> is specified, the INI file is not saved on exit, even if the INI file that was parsed contained a switch to save on exit, or <#QU>--saveini<#NM> was specified. <#QU>--saveini<#NM> is used to force saving to an INI file that does not contain a switch to save on exit. This is a way to force a command-line change into an on-disk INI file.\n"
"\n"
"All section headings appear between square brackets, for example <#QU>[Machine]<#NM>. The names are case-insensitive. All variables in a section have the form <#QU><Name> = <value><#NM>, where <#QU><Name><#NM> is the name of the variable and <#QU><value><#NM> is the value associated with that variable.\n"
"\n"
"Comments can be used in INI files, but note that if a2m saves out an INI file, the comments will be lost. Comments take the form <#QU># Everything after the hash symbol (#) is a comment<#NM>. Comments can appear on lines that also have valid information, for example: <#QU>Variable = Value # assign Value to Variable<#NM>.\n"
"\n"
"<#H1>Machine Section<#NM>\n"
"The Machine section is used to configure the Apple 2 machine that is being emulated. Variables are:\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"Model                <#QU>plus<#NM> or <#QU>enh<#NM>. <#QU>plus<#NM> emulates a ][+, and <#QU>enh<#NM> emulates a //e Enhanced\n"
"Turbo                Comma-separated values as 1 MHz multipliers. <#QU>max<#NM> for as fast as possible\n"
"\n"
"An example Turbo setting might be <#QU>Turbo = 1, 8, max ; This means 1 MHz, 8 MHz, or as fast as possible at 60 FPS<#NM>.\n"
"\n"
"<#H1>Config Section<#NM>\n"
"The Config section is mostly UI configuration. Variables are:\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"disk_leds            Value <#QU>on<#NM> or <#QU>1<#NM> shows disk activity LEDs in the lower right of the UI\n"
"save                 <#QU>yes<#NM> means save the INI file on exit\n"
"symbols              Comma-separated files that contain symbol information\n"
"symbol_view          In disassembler <#QU>0<#NM>: lookup, syms & labels, <#QU>1<#NM>: syms & labels, <#QU>2<#NM>: labels, <#QU>3<#NM>: raw\n"
"ui                   <#QU>text<#NM> for text based UI.  Anything else means GUI based UI\n"
"wheel_speed          Number of lines to scroll when using the mouse scroll wheel\n"
"\n"
"<#H1>Video Section<#NM>\n"
"The Video section has only one valid variable, and it is only used to configure the 80-column card on the Apple ][+ model. Using this will install the Franklin Ace Display card into a slot on an Apple ][+ machine.\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"sNdev                Franklin Ace Display. The <#QU>N<#NM> in <#QU>sNdev<#NM> is a slot number, usually 3\n"
"\n"
"<#H1>DiskII Section<#NM>\n"
"The Disk II section configures an Apple Disk II floppy drive.\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"sNdX                 Comma-separated paths to floppy disk images\n"
"\n"
"The <#QU>N<#NM> and <#QU>X<#NM> in <#QU>sNdX<#NM> are slot and drive numbers. The slot is usually 6, and the drive number can be <#QU>0<#NM> or <#QU>1<#NM>.\n"
"\n"
"Example:\n"
"<#QU>s6d0 = \"./disks/Leaderboard side A.nib\",\"./disks/Leaderboard side B.nib\"<#NM>\n"
"\n"
"In the example, both floppy disk images are configured for a Disk II in slot 6, drive 0. Side A will be mounted, and using the Swap button in the UI, or the Swap action in a breakpoint, the Side B floppy can be swapped into the drive for use.\n"
"\n"
"<#H1>SmartPort Section<#NM>\n"
"The SmartPort section configures a slot for use as a SmartPort block device. These contain block device images, usually 32 MB images (often 33,553,920 bytes) or smaller.\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"sNdX                 Path to a disk image\n"
"bs                   A value of <#QU>1<#NM> will force-boot that device\n"
"\n"
"As with the Disk II section, the values for <#QU>N<#NM> and <#QU>X<#NM> are a valid, unused slot number and device number, where device numbers are <#QU>0<#NM> or <#QU>1<#NM>. Usually the slot numbers are <#QU>5<#NM> or <#QU>7<#NM>. The Apple //e will try to boot from a SmartPort device <#QU>0<#NM> in slot <#QU>7<#NM>. The <#QU>bs<#NM> setting can be used to force an Apple 2 to boot a SmartPort device <#QU>0<#NM> in a slot other than slot <#QU>7<#NM>, or to boot an Apple ][+ from a SmartPort device instead of the Disk II device.\n"
"\n"
"<#H1>Debug Section<#NM>\n"
"The Debug section is not a normal INI section. Normally, a variable (or key, in INI parlance) must have a unique name. In the Debug section, the <#QU>break<#NM> variable is used repeatedly.\n"
"\n"
"The <#QU>break<#NM> variable takes the form:\n"
"<#QU>break = <address[-address]>[,<pc|read|write|access|reset|fast|slow|swap sNdX|tron|troff|type str|count[,reset]><#NM>\n"
"\n"
"In this syntax, elements in <#QU><><#NM> are required, and elements in <#QU>[]<#NM> are optional. When <#QU>|<#NM> is used, it means \"or\". For example, <#QU>[,pc|read|write]<#NM> means an optional comma followed by one of <#QU>pc<#NM>, <#QU>read<#NM>, or <#QU>write<#NM>.\n"
"\n"
"<#BO>* <#QU>address<#NM> is the breakpoint address, usually a hexadecimal number such as <#QU>0x1234<#NM>.\n"
"<#BO>* <#QU>-address<#NM> is optional and makes the breakpoint apply to a range from address to address. This takes the form <#QU>0x8000-0x80ff<#NM>, where <#QU>0x8000<#NM> is the range start and <#QU>0x80ff<#NM> is the range end.\n"
"<#BO>* <#QU>pc<#NM> means this is a breakpoint on code execution.\n"
"<#BO>* <#QU>read<#NM> means the breakpoint is activated by a read from the address or range.\n"
"<#BO>* <#QU>write<#NM> means the breakpoint is activated by a write to the address or range.\n"
"<#BO>* <#QU>access<#NM> means the breakpoint is activated by either a read from or a write to the address or range.\n"
"<#BO>* <#QU>fast<#NM> sets Turbo Mode to <#QU>max<#NM>.\n"
"<#BO>* <#QU>slow<#NM> sets Turbo Mode to 1 MHz.\n"
"<#BO>* <#QU>restore<#NM> sets Turbo Mode back to the value it had before <#QU>slow<#NM> or <#QU>fast<#NM> was used.\n"
"<#BO>* <#QU>swap<#NM> swaps the disk in the drive (Slot N Drive X) to the next disk in the queue.\n"
"<#BO>* <#QU>tron<#NM> turns trace logging on. The log is written to the file <#QU>trace.txt<#NM> in the current folder.\n"
"<#BO>* <#QU>troff<#NM> turns trace logging off.\n"
"<#BO>* <#QU>type<#NM> inserts the characters from <#QU>str<#NM> into the keyboard address.\n"
"<#BO>* <#QU>count<#NM> is a number that sets the breakpoint counter to that value.\n"
"<#BO>* <#QU>reset<#NM> is a number that sets the breakpoint reset counter to that value.\n"
"\n"
"For <#QU>count<#NM> and <#QU>reset<#NM>, the first non-keyword number is assumed to be <#QU>count<#NM>, and the second is <#QU>reset<#NM>.\n"
"\n"
"Here are a few examples:\n"
"\n"
"<#BO>; switch to the second floppy for Disk II in slot 6, drive 0\n"
"<#QU>break = 0x55b5,swap=s6d0\n"
"<#BO>; press enter\n"
"<#QU>break = 0x55b8,type=\\r\n"
"<#BO>; set Turbo Mode to fast, that is, as fast as possible at 60 FPS (max)\n"
"<#QU>break = 0x581e,fast\n"
"<#BO>; after 10 read/write accesses in the range, a break will occur\n"
"<#BO>; thereafter, every second access will cause a break\n"
"<#QU>break = 0x5000-0x5002,access,10,2<#NM>\n"
"\n"
"<#H1>Assembler Section<#NM>\n"
"The assembler section sets up a root file to assemble using the built-in assembler.\n"
"\n"
"<#TB>Variable             Value<#NM>\n"
"source               Fully qualified path to the file\n"
"dest                 <#QU>6502<#NM>, <#QU>64K<#NM>, <#QU>128K<#NM> or <#QU>LC Bank<#NM>. <#QU>6502<#NM> is the default\n"
"auto_run             <#QU>yes<#NM> or <#QU>1<#NM> to auto run after successful assembly\n"
"address              Address at which to start auto-run (example <#QU>0x6000<#NM>)\n"
"reset_stack          <#QU>yes<#NM> or <#QU>1<#NM> to reset/clear the stack when auto-running\n"
"\n"
"Since the assembler is mapped to <#QU>CTRL+F4<#NM>, configuring the assembler settings in an <#QU>.ini<#NM> file makes it possible to assemble and run a program under development by pressing <#QU>CTRL+F4<#NM> after editing the assembly source, without having to restart or stop the emulator.\n"
,
"<#H0>Version History<#NM>\n"
"<#H2>31 Oct 2024<#NM> - <#BO>Initial release\n"
"<#H2> 8 Dec 2024<#NM> - <#BO>Version 1.0 release\n"
"<#H2>10 Dec 2024<#NM> - <#BO>Version 1.1 release\n"
"<#H2>23 Dec 2025<#NM> - <#BO>Version 2.0 release\n"
"    <#NM>The version 2 release is a re-architecture of the entire code base, as well as a rewrite of the 6502 core, adding a 65C02 mode. The Apple //e is also supported, along with many new features such as a NIB Disk II, resizable window, window pane sliders, and many more.\n"
"\n"
};